<BODY scroll=auto><DIV id=header>DBreeze. Documentation.</DIV>
<DIV id=contents>
<STYLE type=text/css>.lst-kix_ur61xqeyv3sy-6>li:before{content:"\0025cf  "}.lst-kix_ur61xqeyv3sy-4>li:before{content:"\0025cb  "}.lst-kix_ur61xqeyv3sy-8>li:before{content:"\0025a0  "}.lst-kix_ur61xqeyv3sy-5>li:before{content:"\0025a0  "}ul.lst-kix_ur61xqeyv3sy-0{list-style-type:none}ul.lst-kix_ur61xqeyv3sy-1{list-style-type:none}.lst-kix_ur61xqeyv3sy-2>li:before{content:"\0025a0  "}ul.lst-kix_ur61xqeyv3sy-2{list-style-type:none}ul.lst-kix_ur61xqeyv3sy-3{list-style-type:none}ul.lst-kix_ur61xqeyv3sy-4{list-style-type:none}ul.lst-kix_ur61xqeyv3sy-5{list-style-type:none}ul.lst-kix_ur61xqeyv3sy-6{list-style-type:none}.lst-kix_ur61xqeyv3sy-3>li:before{content:"\0025cf  "}ul.lst-kix_ur61xqeyv3sy-7{list-style-type:none}ul.lst-kix_ur61xqeyv3sy-8{list-style-type:none}.lst-kix_ur61xqeyv3sy-0>li:before{content:"\0025cf  "}.lst-kix_ur61xqeyv3sy-1>li:before{content:"\0025cb  "}.lst-kix_ur61xqeyv3sy-7>li:before{content:"\0025cb  "}ol{margin:0;padding:0}.c28{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:225.6pt;border-top-color:#000000;border-bottom-style:solid}.c26{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial"}.c21{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c24{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c27{background-color:#ffffff;max-width:451.3pt;padding:72pt 72pt 72pt 72pt}.c29{border-collapse:collapse;margin-right:auto}.c16{color:#1155cc;text-decoration:underline}.c18{padding:0;margin:0}.c17{background-color:#ffffff;color:#ff0000}.c4{color:#ff0000;font-weight:bold}.c14{color:inherit;text-decoration:inherit}.c7{font-weight:bold}.c1{height:11pt}.c6{font-style:italic}.c3{margin-left:36pt}.c5{color:#666666}.c25{color:#ff0000}.c10{font-size:10pt}.c22{font-size:14pt}.c15{margin-left:108pt}.c0{direction:ltr}.c19{color:#800080}.c12{margin-left:72pt}.c13{color:#6aa84f}.c11{text-indent:36pt}.c8{font-size:9pt}.c9{padding-left:0pt}.c23{height:0pt}.title{padding-top:24pt;color:#000000;font-weight:bold;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;font-style:italic;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:bold;font-size:18pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:bold;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;text-align:left}h3{padding-top:14pt;color:#666666;font-weight:bold;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;text-align:left}h4{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;font-style:italic;text-align:left}h5{padding-top:11pt;color:#666666;font-weight:bold;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;text-align:left}h6{padding-top:10pt;color:#666666;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;font-style:italic;text-align:left}</STYLE>

<P class="c2 c0"><SPAN class="c7 c19 c22">Документация БД DBreeze.</SPAN></P>
<P class="c0 c20"><SPAN class="c7 c10 c19">(DBreeze version 01.059.20130812; doc. version 01.029.20130812)</SPAN></P>
<P class="c2 c1 c0"><SPAN class="c7 c10"></SPAN></P><A href="#" name=792f05ffc28a35589889a51c29c2fee75e0d7531></A><A href="#" name=0></A>
<TABLE class=c29 cellSpacing=0 cellPadding=0>
<TBODY>
<TR class=c23>
<TD class=c28>
<P class="c0 c24"><SPAN style="OVERFLOW: hidden; BORDER-TOP: #000000 0px solid; HEIGHT: 100px; BORDER-RIGHT: #000000 0px solid; WIDTH: 153px; BORDER-BOTTOM: #000000 0px solid; MARGIN: 0px; BORDER-LEFT: #000000 0px solid; DISPLAY: inline-block; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px)"><IMG title="" style="HEIGHT: 100px; WIDTH: 153px; MARGIN-LEFT: 0px; MARGIN-TOP: 0px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px)" alt="" src="https://lh3.googleusercontent.com/k1cVwYK5GXnJpCI_e5V2h5UKB4uX46yFD4sGaVH4SUd6nGTKJLf-nVus1ALf5JYvHIr82EJ2kZ7DRzy1lFzeNjYAeIIlJIBA6LIadCJp0CqxDlqWGaXIbOpGXg"></SPAN></P></TD>
<TD class=c28>
<P class="c24 c0"><SPAN class="c6 c26">Профессиональная, с открытым кодом, NoSql (встроенное хранилище Ключ/Значение), транзакционная, ACID-соответствующая, многопоточная система управления базами данных для .NET 4.5&gt; MONO.</SPAN></P>
<P class="c24 c0"><SPAN class="c26 c6">Написанная на C#.</SPAN></P></TD></TR></TBODY></TABLE>
<P class="c2 c1 c0"><SPAN class=c7></SPAN></P>
<P class="c2 c1 c0"><SPAN class="c7 c19"></SPAN></P>
<P class=c0><SPAN class=c7>Copyright © 2012 &nbsp;dbreeze.tiesky.com </SPAN></P>
<P class="c0 c11"><SPAN class=c7>Алексей Соловьёв&nbsp;</SPAN><SPAN class=c8>&lt; </SPAN><SPAN class="c16 c8"><A class=c14 href="mailto:hhblaze@gmail.com">hhblaze@gmail.com</A></SPAN><SPAN class=c8>&nbsp;&gt;</SPAN><SPAN class=c7>&nbsp;</SPAN></P>
<P class="c0 c11"><SPAN class=c7>Иварс Судмалис&nbsp;</SPAN><SPAN class=c8>&lt; </SPAN><SPAN class="c16 c8"><A class=c14 href="mailto:zikills@gmail.com">zikills@gmail.com</A></SPAN><SPAN class=c8>&nbsp;&gt;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Это свободное ПО для тех, кто считает, что оно должно быть свободным.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Пожалуйста, сообщите нам об использование нашего ПО, чтобы мы оценили и вообразили его эффективность.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Document evolution.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This document evolves downside. All new features, if you have read the base document before, will be reflected underneath. New evolution always starts from a mark in format [year month day] - [20120521] - for easy search.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Evolution history [yyyyMMdd]</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN>20140603 - Storing byte[] serialized objects (Protobuf.NET). </SPAN></P>
<P class=c0><SPAN>20130812 - Insert key overload for Master and Nested table, letting not to overwrite key if it already exists.</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- Speeding up select operations and traversals with ValuesLazyLoadingIsOn.</SPAN></P>
<P class=c0><SPAN>20130811 -Remove KeyValue and get deleted value and notification if value existed in one round.</SPAN></P>
<P class=c0><SPAN>20130613 - Full locking of tables inside of transaction.</SPAN></P>
<P class=c0><SPAN>20130610 - Restoring table from the other table.</SPAN></P>
<P class=c0><SPAN>20130529 - Speeding up batch modifications (updates, random inserts) with Technical_SetTable_OverwriteIsNotAllowed instruction.</SPAN></P>
<P class=c0><SPAN>20121111 - Alternative tables storage locations.</SPAN></P>
<P class=c0><SPAN>20121101 - Added new iterators for transaction master and nested tables SelectForwardStartsWithClosestToPrefix and SelectBackwardStartsWithClosestToPrefix.</SPAN></P>
<P class=c0><SPAN>20121023 - DBreeze like in-memory database. “Out-of-the-box” bulk insert speed increase.</SPAN></P>
<P class=c0><SPAN>20121016 - Secondary Indexes. Going deeper. Part 2.</SPAN></P>
<P class=c0><SPAN>20121015 - Secondary Indexes. Going deeper.</SPAN></P>
<P class=c0><SPAN>20121012 - Behaviour of the iterators with the modification instructions inside.</SPAN></P>
<P class=c0><SPAN>20120922 - !!!! Important, attach new DBreeze and recompile your project, if you have errors concerning DateTime conversion functions - read the docu article.</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Storing virtual columns in the value, null-able datatypes and null-able text of fixed length.</SPAN></P>
<P class=c0><SPAN>20120905 - Support of incremental backup. </SPAN></P>
<P class=c0><SPAN>20120628 - Row has property LinkToValue</SPAN></P>
<P class=c0><SPAN>20120601 - Storing inside of a row a column of dynamic data length. InsertDataBlock</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;- Hash Functions of common usage. Fast access to long strings and byte arrays. </SPAN><SPAN class=c5>(</SPAN><SPAN class="c6 c5">updated 20121012</SPAN><SPAN class=c5>)</SPAN><SPAN>.</SPAN></P>
<P class=c0><SPAN>20120529 - Nested tables memory management. Nested Table Close(), controlling memory consumption.</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;- Secondary Index. Direct key select.</SPAN></P>
<P class=c0><SPAN>20120526 - InsertDictionary/SelectDictionary &nbsp;InsertHashSet/SelectHashSet continuation.</SPAN></P>
<P class=c0><SPAN>20120525 - Row.GetTable().</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;InsertDictionary/SelectDictionary &nbsp;InsertHashSet/SelectHashSet</SPAN></P>
<P class=c0><SPAN>20120521 - Fractal Tables structure description and usage techniques.</SPAN></P>
<P class=c0><SPAN>20120509 - Basic techniques description</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120509]</SPAN></P>
<P class=c0><SPAN class="c7 c13">Getting started.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze.dll contains fully managed code without references to other libraries. Current DLL size is around 274 KB. Start using it by adding its reference to your project. Don’t forget DBreeze.XML from Release folder to get VS IntelliSense help.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze is a disk based database system, though it also can work like in-memory storage.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Dbreeze doesn’t have virtual file system underneath and resides all working files in your OS file system, that’s why you must instantiate its engine by supplying a folder name where all files will be located.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Main DBreeze </SPAN><SPAN class=c7>namespace </SPAN><SPAN>is </SPAN><SPAN class=c7>DBreeze</SPAN><SPAN>.</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>DBreezeEngine engine = null;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>if(engine == null)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; engine = new DBreezeEngine(@"D:\temp\DBR1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>It’s </SPAN><SPAN class=c7>important </SPAN><SPAN>in the </SPAN><SPAN class=c7>Dispose </SPAN><SPAN>function of your application or DLL to call DBreeze engine Dispose, to have graceful application termination.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>if(engine != null)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.Dispose();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>After you have instantiated the engine two options will be available for you, either to work with the database scheme or to work with the transactions.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Scheme.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You don’t need to create tables via scheme, it’s needed to make manipulations with already existing objects.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Deleting table:</SPAN></P>
<P class=c0><SPAN class=c5>engine.Scheme.DeleteTable(string userTableName)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Getting specific tables names:</SPAN></P>
<P class=c0><SPAN class=c5>engine.Scheme.GetUserTableNamesStartingWith(string mask)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Renaming table:</SPAN></P>
<P class=c0><SPAN class=c5>engine.Scheme.RenameTable(string oldTableName, string newTableName)</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>Checking if table exists:</SPAN></P>
<P class=c0><SPAN class=c5>engine.Scheme.IfUserTableExists(string tableName)</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>Getting physical path to the file holding the table:</SPAN></P>
<P class=c0><SPAN class=c5>engine.Scheme.GetTablePathFromTableName(string tableName)</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c6>Later more functions will be added there and their description here.</SPAN></P>
<P class="c1 c0"><SPAN class=c6></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Transactions</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN>In DBreeze all operations with the data, which resides inside of the tables, must occur inside of the transaction.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We open transaction like this:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c7>Please note</SPAN><SPAN>, that it’s </SPAN><SPAN class=c7>important </SPAN><SPAN>to dispose transaction after all necessary operations are done (using-statement makes it automatically).</SPAN></P>
<P class=c0><SPAN class=c7>Please note</SPAN><SPAN>, that one transaction can be run only in </SPAN><SPAN class=c7>one </SPAN><SPAN>.NET managed thread and can not be delegated to other threads.</SPAN></P>
<P class=c0><SPAN class=c7>Please note</SPAN><SPAN>, that nested transactions are </SPAN><SPAN class=c7>not </SPAN><SPAN>allowed (parent transaction will be terminated)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>During in-transactional operations different things can happen that’s why we </SPAN><SPAN class=c7>highly recommend</SPAN><SPAN>&nbsp;to use try-catch block together with the transaction and </SPAN><SPAN class=c7>log exceptions </SPAN><SPAN>for the future analysis.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>try</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c0 c11"><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class=c0><SPAN class=c5>catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table data types</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN>Every table in DBreeze is a key/value storage. On the low level, &nbsp;keys and values represent arrays of bytes - byte[]. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>On the top level you can choose your own data type, from allowed list, to be stored as a key or value.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>There are some not standard data types in DBreeze, added for usability, they are accessible</SPAN></P>
<P class="c2 c0"><SPAN>inside of DBreeze.DataTypes namespace.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze.DataTypes;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table data types. Key data types</SPAN></P>
<P class="c1 c0"><SPAN class=c13></SPAN></P>
<P class=c0><SPAN>Keys </SPAN><SPAN class=c7>can not</SPAN><SPAN>&nbsp;contain </SPAN><SPAN class=c7>NULLABLE </SPAN><SPAN>datatypes.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note, that key in the table is always unique.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Here is a list of available data types for the key:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Keys data types</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[]</SPAN></P>
<P class=c0><SPAN>int</SPAN></P>
<P class="c2 c0"><SPAN>uint</SPAN></P>
<P class="c2 c0"><SPAN>long</SPAN></P>
<P class="c2 c0"><SPAN>ulong</SPAN></P>
<P class="c2 c0"><SPAN>short</SPAN></P>
<P class="c2 c0"><SPAN>ushort</SPAN></P>
<P class="c2 c0"><SPAN>byte</SPAN></P>
<P class="c2 c0"><SPAN>sbyte</SPAN></P>
<P class="c2 c0"><SPAN>DateTime</SPAN></P>
<P class="c2 c0"><SPAN>double</SPAN></P>
<P class="c2 c0"><SPAN>float</SPAN></P>
<P class="c2 c0"><SPAN>decimal</SPAN></P>
<P class=c0><SPAN>string &nbsp;</SPAN><SPAN class=c6>- &nbsp;this one will be converted into byte[] using UTF8 encoding</SPAN></P>
<P class="c2 c0"><SPAN>DbUTF8 &nbsp;</SPAN><SPAN class=c6>- &nbsp;this one will be converted into byte[] using UTF8 encoding</SPAN></P>
<P class="c2 c0"><SPAN>DbAscii </SPAN><SPAN class=c6>&nbsp;- &nbsp;this one will be converted into byte[] using Ascii encoding</SPAN></P>
<P class="c2 c0"><SPAN>DbUnicode</SPAN><SPAN class=c6>&nbsp;- &nbsp;this one will be converted into byte[] using Unicode encoding</SPAN></P>
<P class=c0><SPAN>char</SPAN></P>
<P class="c1 c0"><SPAN class=c6></SPAN></P>
<P class=c0><SPAN class=c7>Value data types</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[]</SPAN></P>
<P class=c0><SPAN>int</SPAN></P>
<P class=c0><SPAN>int?</SPAN></P>
<P class=c0><SPAN>uint</SPAN></P>
<P class=c0><SPAN>uint?</SPAN></P>
<P class=c0><SPAN>long</SPAN></P>
<P class=c0><SPAN>long?</SPAN></P>
<P class=c0><SPAN>ulong</SPAN></P>
<P class=c0><SPAN>ulong?</SPAN></P>
<P class=c0><SPAN>short</SPAN></P>
<P class=c0><SPAN>short?</SPAN></P>
<P class=c0><SPAN>ushort</SPAN></P>
<P class=c0><SPAN>ushort?</SPAN></P>
<P class=c0><SPAN>byte</SPAN></P>
<P class=c0><SPAN>byte?</SPAN></P>
<P class=c0><SPAN>sbyte</SPAN></P>
<P class=c0><SPAN>sbyte?</SPAN></P>
<P class=c0><SPAN>DateTime</SPAN></P>
<P class=c0><SPAN>DateTime?</SPAN></P>
<P class=c0><SPAN>double</SPAN></P>
<P class=c0><SPAN>double?</SPAN></P>
<P class=c0><SPAN>float</SPAN></P>
<P class=c0><SPAN>float?</SPAN></P>
<P class=c0><SPAN>decimal</SPAN></P>
<P class=c0><SPAN>decimal?</SPAN></P>
<P class="c2 c0"><SPAN>string </SPAN><SPAN class=c6>- &nbsp;this one will be converted into byte[] using UTF8 encoding</SPAN></P>
<P class="c2 c0"><SPAN>DbUTF8 </SPAN><SPAN class=c6>- &nbsp;this one will be converted into byte[] using UTF8 encoding</SPAN></P>
<P class="c2 c0"><SPAN>DbAscii </SPAN><SPAN class=c6>- &nbsp;this one will be converted into byte[] using Ascii encoding</SPAN></P>
<P class="c2 c0"><SPAN>DbUnicode </SPAN><SPAN class=c6>- &nbsp;this one will be converted into byte[] using Unicode encoding</SPAN></P>
<P class=c0><SPAN>bool</SPAN></P>
<P class=c0><SPAN>bool?</SPAN></P>
<P class=c0><SPAN>char</SPAN></P>
<P class=c0><SPAN>char?</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And some more exotic data types like:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>DbXML&lt;T&gt;</SPAN></P>
<P class=c0><SPAN class=c7>DbMJSON&lt;T&gt;</SPAN></P>
<P class=c0><SPAN class=c7>DbCustomSerializer&lt;T&gt;</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>they are used for storing objects inside of the value, we will talk about them later.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Inserting data</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>All operations with the data, except operations which can be done via scheme, must be done inside of the transaction scope. By pressing tran. intellisense will give you a list of all possible operations. We start from inserting data into the table.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>public void Example_InsertingData()</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", 1, 1);</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>In this example we have inserted data into the table with the name “t1”. </SPAN><SPAN class=c7>Table </SPAN><SPAN>will be </SPAN><SPAN class=c7>created automatically</SPAN><SPAN>, if it doesn’t exist. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Key type for our table is int 1, value type of table is also int (also 1).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>After one or series of modifications inside of the transaction we must either Commit them or Rollback them.</SPAN></P>
<P class=c0><SPAN>Note, </SPAN><SPAN class=c7>Rollback </SPAN><SPAN>function will </SPAN><SPAN class=c7>automatically run</SPAN><SPAN>&nbsp;in the </SPAN><SPAN class=c7>transaction Dispose</SPAN><SPAN>&nbsp;function, so all not committed modifications of the database inside of transaction will be automatically rolled-back.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You can be sure that this modification will not be applied to the table, but nevertheless empty table will be created, if it doesn’t exist before.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", 1, 1);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>//NO COMMIT</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We don’t store in the table data types, which you assume must be there, table holds only byte arrays of keys and values and only on the upper level acquired byte[] will be converted into keys or values of the appropriate data types from generic constructions.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You can modify more then one table inside of the transaction.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", 1, 1);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;uint, string&gt;("t2", 1, “hello”);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c12"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c0 c12"><SPAN class=c5>//or</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>//tran.Rollback();</SPAN></P>
<P class="c2 c1 c0 c12"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>tran.Insert&lt;int, int&gt;("t1", 2, 1);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;uint, string&gt;("t2", 2, “world”);</SPAN></P>
<P class="c2 c1 c0 c12"><SPAN class=c5></SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Commits and Rollbacks</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Used Commit or Rollback will be applied to all modifications inside of the transaction. If something happens during Commit all data will be automatically rolled-back for all modifications. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>The only acceptable reason for Rollback fail can be the damage of the physical storage, and exceptions in the rollback procedure will bring database to the not operable state.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze database, after its start, checks transactions journal and restores tables into their previous state, so there should be no problems with the power loss or any other accidental software termination in any process execution point.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze database is fully </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://en.wikipedia.org/wiki/ACID&amp;sa=D&amp;usg=AFQjCNHkM6ImxCmv92tsKneA15CYWArLRg">ACID</A></SPAN><SPAN>&nbsp;compliant.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Commit </SPAN><SPAN>operation is always very </SPAN><SPAN class=c7>fast </SPAN><SPAN>and takes the same amount of time independent of the quantity of modifications made.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Rollback </SPAN><SPAN>can take </SPAN><SPAN class=c7>longer</SPAN><SPAN>, depending upon the </SPAN><SPAN class=c7>quantity of data and character of modifications,</SPAN><SPAN>&nbsp;which were made within the database.</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Updates</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Update key operation is the same as insert operation</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;int, int&gt;("t1", 2, 1);</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;int, int&gt;("t1", 2, 2);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>we have updated key 2 and setup new value 2.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Bulk operations</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN>If you are going to insert or update a big data set then first execute insert, update, remove command as many times as you need and then call tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Calling tran.</SPAN><SPAN class=c7>Commit</SPAN><SPAN>&nbsp;after every operation, </SPAN><SPAN class=c7>will not make table physical file bigger</SPAN><SPAN>&nbsp;but will take more time then one Commit after all operations.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//THIS IS FASTER </SPAN></P>
<P class="c2 c0 c11"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;1000000;i++)</SPAN></P>
<P class="c15 c0"><SPAN class=c5>{</SPAN></P>
<P class="c15 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int,int&gt;(“t1”,i,i)</SPAN></P>
<P class="c15 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c15 c0"><SPAN class=c5></SPAN></P>
<P class="c15 c0"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c15 c0"><SPAN class=c5></SPAN></P>
<P class="c15 c0"><SPAN class=c5>//THIS IS SLOWER</SPAN></P>
<P class="c1 c15 c0"><SPAN class=c5></SPAN></P>
<P class="c15 c0"><SPAN class=c5>for(int i=0;i&lt;1000000;i++)</SPAN></P>
<P class="c15 c0"><SPAN class=c5>{</SPAN></P>
<P class="c15 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int,int&gt;(“t1”,i,i)</SPAN></P>
<P class="c15 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c15 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c15 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Random keys while bulk insert.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Dbreeze algorithms are built to work with maximum efficiency while inserting in bulk sorted ascending data. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>for(int i=0;i&lt;1000000;i++)</SPAN></P>
<P class="c15 c0"><SPAN class=c5>{</SPAN></P>
<P class="c15 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int,int&gt;(“t1”,i,i);</SPAN></P>
<P class="c0 c15"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//or</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime dt=DateTime.Now;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>for(int i=0;i&lt;1000000;i++)</SPAN></P>
<P class="c15 c0"><SPAN class=c5>{</SPAN></P>
<P class="c15 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;DateTime, int &gt;(“t1”,dt,i);</SPAN></P>
<P class="c15 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt=dt.AddSeconds(7);</SPAN></P>
<P class="c15 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c5>tran.Commit();</SPAN></P>
<P class=c0><SPAN>The above code will execute 9 seconds (year 2012). </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you start to insert data in random order it can take up to some minutes. That’s why, if you have in-memory big data set, before saving it to the database, sort it ascending in-memory by key and then insert. It will speed up your program.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you make copy from other databases to DBreeze, take a chunk (e.g. 1 MLN records), sort it in memory by key ascending, insert into DBreeze, them take another chunk and so on.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Partial Insert or Update</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>In DBreeze </SPAN><SPAN class=c7>maximal key length</SPAN><SPAN>&nbsp;in bytes is 65535 (UInt16.MaxValue) and maximal </SPAN><SPAN class=c7>value length</SPAN><SPAN>&nbsp;is &nbsp;2147483647 (Int32.MaxValue).</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>It’s not possible to save as a value byte array bigger then 2GB. For bigger data elements we will have to develop in the future other strategy.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>In Dbreeze we have ability of a partial value update or insert. It’s possible because values are stored as byte[]. It doesn’t matter which data type is stored already in the table you can always access it and change as byte array.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>DBreeze has special namespace inside, which allows you easily to work with byte arrays.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>using DBreeze.Utils;</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>Now you can convert any standard data type into byte array and back.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>We will achieve the same effect in all following records:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.Insert&lt;int,</SPAN><SPAN class="c7 c5">&nbsp;int</SPAN><SPAN class=c5>&gt;("t1", 10, 1);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>//or</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;int, </SPAN><SPAN class="c7 c5">byte[]</SPAN><SPAN class=c5>&gt;("t1", 10, ((int)1).To_4_bytes_array_BigEndian());</SPAN></P>
<P class=c0><SPAN class=c5>//or</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;int, </SPAN><SPAN class="c7 c5">byte[]</SPAN><SPAN class=c5>&gt;("t1", 10, new byte[] {0x80, 0x00, 0x00, 0x01});</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>Above instructions can be run one by one and will bring to the result then under key 10 we will have value 1.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And the same result we will achieve having run 4 following instructions:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 10, new byte[] { 0x80 }, 0);</SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 10, new byte[] { 0x00 }, 1);</SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 10, new byte[] { 0x00 }, 2);</SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 10, new byte[] { 0x01 }, 3);</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>//or the same</SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 10, new byte[] { 0x80 ,0x00}, 0);</SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 10, new byte[] { 0x00 ,0x01}, 2);</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>The fourth parameter of tran.InsertPart is exactly the index from which we want to insert our byte[] array.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>This </SPAN><SPAN class=c7>technique</SPAN><SPAN>&nbsp;can be used by us, if we think about the value as about the </SPAN><SPAN class=c7>set of columns</SPAN><SPAN>&nbsp;of the known length, like in </SPAN><SPAN class=c7>standard SQL databases</SPAN><SPAN>, and gives us ability to change every column separately, without changing all other values.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Note, </SPAN><SPAN>you can always </SPAN><SPAN class=c7>switch to byte[] data type</SPAN><SPAN>&nbsp;in values and in keys</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.Insert&lt;int,</SPAN><SPAN class="c7 c5">&nbsp;int</SPAN><SPAN class=c5>&gt; </SPAN></P>
<P class="c2 c0"><SPAN class=c5>//or </SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.Insert&lt;int,</SPAN><SPAN class="c7 c5">&nbsp;byte[]</SPAN><SPAN class=c5>&gt; </SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>if it’s interesting for you.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Note, </SPAN><SPAN>If you want to insert or update value starting from the </SPAN><SPAN class=c7>index which is bigger then current value</SPAN><SPAN>&nbsp;length, the empty space will be filled with byte[] { 0 }.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>We didn’t have before key 12 and now we are executing following commands:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 12, new byte[] { 0x80 }, </SPAN><SPAN class="c7 c5">0</SPAN><SPAN class=c5>);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 12, new byte[] { 0x80 }, </SPAN><SPAN class="c7 c5">10</SPAN><SPAN class=c5>);</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Value as byte[] will look like this:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>"0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x80"</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Note</SPAN><SPAN>, Dbreeze will try to use the </SPAN><SPAN class=c7>same physical file space while record update,</SPAN><SPAN>&nbsp;if existing record length is suitable for this.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class="c7 c13">Table operations. Data Fetching. Select.</SPAN></P>
<P class="c2 c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c2 c0"><SPAN>Method tran.Select is designed for getting one single key:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", 10, 2);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c2"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var row = tran.Select&lt;int, </SPAN><SPAN class="c7 c5">int</SPAN><SPAN class=c5>&gt;("t1", 10);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //</SPAN><SPAN class="c7 c5">or will work also good</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var row = tran.Select&lt;int, </SPAN><SPAN class="c7 c5">byte[]</SPAN><SPAN class=c5>&gt;("t1", 10);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>After select you must supply in generic format data types for the key and value.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>In our case, we want to read from table “t1” key of type int (its value 10). </SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Select always returns a value of type DBreeze.DataTypes.Row</SPAN><SPAN>.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>We can </SPAN><SPAN class=c7>start to visualize</SPAN><SPAN>&nbsp;the key value </SPAN><SPAN class=c7>only after checking,</SPAN><SPAN>&nbsp;if table has such value inside.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Row </SPAN><SPAN>has </SPAN><SPAN class=c7>property Exists</SPAN><SPAN>:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c2 c0"><SPAN class=c5>{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", 10, 2);</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var row = tran.Select&lt;int, int&gt;("t1", 10);</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] btRes = null;</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int res=0;</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int key=0;</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</SPAN><SPAN class="c7 c5">row.Exists</SPAN><SPAN class=c5>)</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = row.Key;</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = row.Value;</SPAN></P>
<P class="c2 c1 c0 c12"><SPAN class=c5></SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class="c7 c5">//btRes will be null, because we have only 4 bytes</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btRes = row.GetValuePart(12); &nbsp; &nbsp; </SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN><SPAN class="c7 c5">//btRes will be null, because we have only 4 bytes</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btRes = row.GetValuePart(12, 1);</SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//will return 4 bytes</SPAN></P>
<P class="c2 c15 c0 c11"><SPAN class=c5>btRes = row.GetValuePart(0); </SPAN></P>
<P class="c0 c12"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//will return 4 bytes</SPAN></P>
<P class="c15 c0 c11"><SPAN class=c5>btRes = row.GetValuePart(0,4); </SPAN></P>
<P class="c2 c0 c12"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class=c5>catch (Exception ex)</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c0"><SPAN class=c5>}</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>So, if row exists, we can start to fetch its key (</SPAN><SPAN class=c7>row.Key</SPAN><SPAN>), full record </SPAN><SPAN class=c7>row.Value</SPAN><SPAN>&nbsp;(it will be automatically converted from byte[] to the data type, which you gave while forming Select). And independent from the record data type, Row has method </SPAN><SPAN class=c7>GetValuePart </SPAN><SPAN>with overloads which will help you to get value partially and always as byte[]. DBreeze.Utils extensions can help to convert values to other data types.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>If we had in the value, starting from index 4 stored some kind of ulong, which resides 8 bytes, we can say:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>ulong x = row.GetValuePart(4,8).To_UInt64_BigEndian();</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Note</SPAN><SPAN>, that </SPAN><SPAN class=c7>DBreeze.Utils conversion algorithms are exactly sharpened for DBreeze data types, because they create sortable byte[] sequences in compare with .NET built in byte[] conversion functions</SPAN><SPAN>.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Data Fetching. NULL</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.Insert&lt;int,int?&gt;(“t1”,10,null);</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>var row = tran.Select&lt;int,int?&gt;(“t1”,10);</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>if(row.Exists)</SPAN></P>
<P class="c2 c0"><SPAN class=c5>{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int? val = row.Value; //val will be null</SPAN></P>
<P class="c2 c0"><SPAN class=c5>}</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class="c7 c13">Table operations. Data Fetching. Order by. Order by Descending.</SPAN></P>
<P class="c2 c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c2 c0"><SPAN>When </SPAN><SPAN class=c7>Dbreeze stores data</SPAN><SPAN>&nbsp;in the table it’s </SPAN><SPAN class=c7>automatically </SPAN><SPAN>stored in the </SPAN><SPAN class=c7>sorted </SPAN><SPAN>order. That’s why all range selects are very fast. This example is taken from satellite project integrated into DBreeze solution, which is called VisualTester from class DocuExamples:</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>public void Example_FetchingRange()</SPAN></P>
<P class="c2 c0"><SPAN class=c5>{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.Scheme.DeleteTable("t1");</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0 c11"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.StartCounter("INSERT");</SPAN></P>
<P class="c2 c1 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime dt = DateTime.Now;</SPAN></P>
<P class="c2 c0 c11"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 1000000; i++)</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;DateTime, byte?&gt;("t1", dt, null);</SPAN></P>
<P class="c2 c0 c11"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt = dt.AddSeconds(7);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0 c3"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.StopCounter("INSERT");</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.PrintOut(true);</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.StartCounter("FETCH");</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">foreach (var row in tran.SelectForward&lt;DateTime, byte?&gt;("t1"))</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Console.WriteLine("K: {0}; V: {1}", row.Key.ToString("dd.MM.yyyy HH:mm:ss"), (row.Value == null) ? "NULL" : row.Value.ToString());</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.StopCounter("FETCH");</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.PrintOut(true);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>}</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c5>A small benchmark for this procedure:</SPAN></P>
<P class="c2 c0"><SPAN class="c7 c5">INSERT: &nbsp;10361 ms; 28312951 ticks</SPAN></P>
<P class="c2 c0"><SPAN class="c7 c5">FETCH: &nbsp; 4700 ms; 12844468 ticks</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c7>All range selects methods in DBreeze return IEnumerable&lt;Row&lt;TKey,TValue&gt;&gt;, so they can be used in foreach statements.</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c7></SPAN></P>
<P class="c2 c1 c0"><SPAN class=c7></SPAN></P>
<P class="c2 c0"><SPAN class=c7>If you want, you can break from foreach in any moment.</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN>To limit the quantity of the data you can use, either break iteration or use </SPAN><SPAN class=c7>Take </SPAN><SPAN>statement</SPAN><SPAN class=c7>:</SPAN></P>
<P class="c2 c1 c0"><SPAN class="c7 c5"></SPAN></P>
<P class=c0><SPAN class=c5>foreach (var row in tran.SelectForward&lt;DateTime, byte?&gt;("t1").</SPAN><SPAN class="c7 c5">Take</SPAN><SPAN class=c5>(100))</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c1 c0"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c7>SelectForward - </SPAN><SPAN>starts from the first key and iterates forward to the last key in sorted </SPAN><SPAN class=c7>ascending </SPAN><SPAN>order.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>SelectBackward </SPAN><SPAN>- starts from the last key and iterates backward to the first key in sorted </SPAN><SPAN class=c7>descending </SPAN><SPAN>order.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Transaction has more self-explained methods:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>IEnumerable&lt;Row&lt;TKey, TValue&gt;&gt; </SPAN><SPAN class=c7>SelectForwardStartFrom</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName,TKey key, bool includeStartFromKey) - </SPAN><SPAN class=c7>Note, if key is not found then it starts from the next available key forward in ascending order, idea of non-existing supplied parameter concerns all iterational methods.</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c7></SPAN></P>
<P class="c2 c0"><SPAN class=c7>SelectBackwardStartFrom</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey key, bool includeStartFromKey) - iterates from the given key down in descending order.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>SelectForwardFromTo</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey startKey, bool includeStartKey, TKey stopKey, bool includeStopKey)</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>SelectBackwardFromTo</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey startKey, bool includeStartKey, TKey stopKey, bool includeStopKey)</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c4>DON’T </SPAN><SPAN>USE </SPAN><SPAN class=c4>LINQ </SPAN><SPAN>after </SPAN><SPAN class=c7>SelectForward or SelectBackward for filtering like this:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.SelectForward&lt;int,int&gt;(“t1”).Where(r=&gt;r.Key &gt; 10).Take(10)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Because it will work </SPAN><SPAN class=c7>much much much slower </SPAN><SPAN>then specially sharpened methods,</SPAN></P>
<P class=c0><SPAN>use instead:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>tran.</SPAN><SPAN class=c7>SelectForwardStartFrom</SPAN><SPAN>&lt;int,int&gt;("t1",10,false).Take(10)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And finally two more special methods:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectForwardStartsWith</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey startWithKeyPart)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectBackwardStartsWith</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey startWithKeyPart)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You remember that all data types will be converted into byte[]. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So if in table we have keys</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x15, 0x17}</SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x16, 0x17}</SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x15, 0x19}</SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x17, 0x18}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>then </SPAN></P>
<P class=c0><SPAN>SelectForwardStartsWith&lt;byte[],int&gt;(“t1”,new byte[] {0x12})</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will return us all keys</SPAN></P>
<P class=c0><SPAN>SelectForwardStartsWith&lt;byte[],int&gt;(“t1”,new byte[] {0x12, 0x15})</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will return us only 2 keys</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x15, 0x17}</SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x15, 0x19}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectBackwardStartsWith</SPAN><SPAN>&lt;byte[],int&gt;(“t1”,new byte[] {0x12, 0x15})</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will return us only 2 keys in descending order</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x15, 0x19}</SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x15, 0x17}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>SelectForwardStartsWith&lt;byte[],int&gt;(“t1”,new byte[] {0x12, 0x17})</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will return us 1 key</SPAN></P>
<P class=c0><SPAN>byte[] {0x12, 0x17, 0x18}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and </SPAN></P>
<P class=c0><SPAN>SelectForwardStartsWith&lt;byte[],int&gt;(“t1”,new byte[] {0x10, 0x17})</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will return nothing.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Having this idea we can effectively work with strings:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;string,string&gt;(“t1”,”w”,”w”);</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;string,string&gt;(“t1”,”ww”,”ww”);</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;string,string&gt;(“t1”,”www”,”www”);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>then </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectForwardStartsWith</SPAN><SPAN>&lt;string,string&gt;(“t1”,”ww”)</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>will return us</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>“ww”</SPAN></P>
<P class=c0><SPAN>“www”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and </SPAN><SPAN class=c7>SelectBackwardStartsWith</SPAN><SPAN>&lt;string,string&gt;(“t1”,”ww”)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will return us</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>“www”</SPAN></P>
<P class=c0><SPAN>“ww”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Skip</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In Dbreeze we have ability to start iterations after Skipping some other keys:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>this command skips “skippingQuantity” elements and then starts enumeration in ascending order:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectForwardSkip</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, ulong skippingQuantity)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>this command skips “skippingQuantity” elements backward and then starts enumeration in descending order:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>IEnumerable&lt;Row&lt;TKey, TValue&gt;&gt; </SPAN><SPAN class=c7>SelectBackwardSkip</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName,ulong skippingQuantity)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>this command skips “skippingQuantity” elements from the specified key (if key is not found then next one after it will be taken as skipped 1) and then starts enumeration in ascending order:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectForwardSkipFrom</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey key, ulong skippingQuantity)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>this command skips “skippingQuantity” elements backward from the specified key and then starts enumeration in descending order:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SelectBackwardSkipFrom</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey key, ulong skippingQuantity)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note, that skip needs to iterate via keys, to calculate exact skipping quantity</SPAN><SPAN>. That’s why developer has always to take into consideration the idea of the finding compromise between speed and skipping quantity. Skipping 1 MLN, of elements in </SPAN><SPAN class=c7>any direction </SPAN><SPAN>starting from </SPAN><SPAN class=c7>any key</SPAN><SPAN>&nbsp;will take 4 seconds with Intel i7 8 cores and SCSI drive 8GB RAM (year 2012). Skip of 100 000 records will take 400 ms, 10 000 will take 40 ms respectively.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, if you are going to implement grid paging, then just remember first shown in the grid key and then skip from it quantity of shown in the grid elements using </SPAN><SPAN class=c7>SelectForwardSkipFrom </SPAN><SPAN>or </SPAN><SPAN class=c7>SelectBackwardSkipFrom</SPAN><SPAN>. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Count.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For getting </SPAN><SPAN class=c7>Table </SPAN><SPAN>records </SPAN><SPAN class=c7>quantity </SPAN><SPAN>use:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>ulong cnt = tran.</SPAN><SPAN class="c7 c5">Count</SPAN><SPAN class=c5>("t1");</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Count is calculated while inserting and removing operations and is always available.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Max.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>var row = tran.</SPAN><SPAN class="c7 c5">Max</SPAN><SPAN class=c5>&lt;int, int&gt;("t1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>if (row.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>//etc...</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Min.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>var row = tran.</SPAN><SPAN class="c7 c5">Min</SPAN><SPAN class=c5>&lt;int, int&gt;("t1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>if (row.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>//etc...</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class="c7 c13">Table operations. Reading from non-existing table</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>If you try to read from non-existing table, this </SPAN><SPAN class=c7>table will no be created</SPAN><SPAN>&nbsp;in the file system.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>tran.Count will return 0</SPAN></P>
<P class="c2 c0"><SPAN>tran.Select, tran.Min, tran.Max will return row with row.Exists == false</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Range selects like tran.SelectForward etc. will return nothing in your foreach statement.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Removing keys</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To </SPAN><SPAN class=c7>remove one key</SPAN><SPAN>&nbsp;use</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.RemoveKey&lt;int&gt;("t1",10)</SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To </SPAN><SPAN class=c7>Remove all keys</SPAN><SPAN>&nbsp;use</SPAN></P>
<P class=c0><SPAN class=c7>tran.RemoveAllKeys</SPAN><SPAN>(string tableName, bool withFileRecreation)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, if </SPAN><SPAN class=c7>withFileRecreation </SPAN><SPAN>parameter is set to </SPAN><SPAN class=c7>true</SPAN><SPAN>, then we </SPAN><SPAN class=c7>don’t </SPAN><SPAN>need to </SPAN><SPAN class=c7>Commit </SPAN><SPAN>this modification, it will be done automatically. The file who holds the table will be re-created.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, if </SPAN><SPAN class=c7>withFileRecreation </SPAN><SPAN>parameter is set to </SPAN><SPAN class=c7>false, </SPAN><SPAN>the old data will be not visible any more, but the old information will still reside in the table. We </SPAN><SPAN class=c7>need Commit </SPAN><SPAN>after this modification.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table operations. Change key</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have an ability to change the key.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>After these commands:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.Insert&lt;int,int&gt;(“t1”,10,10);</SPAN></P>
<P class=c0><SPAN class=c5>tran.ChangeKey&lt;int&gt;("t1", 10, 11);</SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>&nbsp;we will have in the table one key 11 with the value 10.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>After these commands:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;int,int&gt;(“t1”,10,10);</SPAN></P>
<P class="c2 c0"><SPAN class=c5>tran.Insert&lt;int,int&gt;(“t1”,11,11);</SPAN></P>
<P class=c0><SPAN class=c5>tran.ChangeKey&lt;int&gt;("t1", 10, 11);</SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>we will have in the table one key 11 with the value 10. (old value for the key 11 will be lost)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Storing objects in the database</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For storing objects in the table we have 3 extra data types which are accessible via </SPAN></P>
<P class=c0><SPAN>DBreeze.DataTypes namespace.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>DbXML&lt;T&gt;</SPAN><SPAN>&nbsp; - will automatically use built-in .NET XML serializer and de-serializer for objects. Slower then others in both operations furthermore data resides much more physical space, then others.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>DbMJSON&lt;T&gt;</SPAN><SPAN>&nbsp;- Microsoft JSON, will automatically use built-in .NET JSON &nbsp;(System.Web.Script.Serialization.JavaScriptSerializer) serializer and de-serializer for objects. Much better then XML but not so good as serializer provided by </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://json.codeplex.com/&amp;sa=D&amp;usg=AFQjCNFGpdCvzBHtjWdP_m8j7aeLHfyAEw">http://json.codeplex.com/</A></SPAN><SPAN>&nbsp; - JSON.NET, though resides approximately the same physical space on the disk.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>DbCustomSerializer&lt;T&gt;</SPAN><SPAN>&nbsp;- gives you ability to attach your own serializer like </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://json.codeplex.com/&amp;sa=D&amp;usg=AFQjCNFGpdCvzBHtjWdP_m8j7aeLHfyAEw">http://json.codeplex.com/</A></SPAN><SPAN>&nbsp;. &nbsp;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To attach JSON.NET, download it, refer to your project and fill some lines:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>DBreeze.Utils.CustomSerializator.Serializator = JsonConvert.SerializeObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Utils.CustomSerializator.Deserializator = JsonConvert.DeserializeObject;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>now you can use serialization and de-serialization provided by JSON.NET.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But if you don’t want to use JSON.NET, try Microsoft JSON. It’s about 40% slower on deserialization and 5-10% slower on serialization then JSON.NET.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Use all of them in following manner:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>public class Article</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public uint Id { get; set; }</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public string Name { get; set; }</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c0 c1"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>public void Example_InsertingObject()</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.Schema.DeleteTable("Articles");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SynchronizeTables("Articles");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint identity = 0;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var row = tran.Max&lt;uint, byte[]&gt;("Articles");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (row.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identity = row.Key;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identity++;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Article art=new Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id = identity,</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = "PC"</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", identity, art);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, DbMJSON, DbXML, DbMJSON,DbCustomSerializer have overloaded operator and you can specify art without saying new DbMJSON&lt;Article&gt;, just say art:</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", identity, </SPAN><SPAN class="c7 c5">art</SPAN><SPAN class=c5>);</SPAN></P>
<P class=c0><SPAN class=c5>//or</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;uint, DbXML&lt;Article&gt;&gt;("Articles", identity, </SPAN><SPAN class="c7 c5">art</SPAN><SPAN class=c5>);</SPAN></P>
<P class=c0><SPAN class=c5>//or</SPAN></P>
<P class=c0><SPAN class=c5>tran.Insert&lt;uint, DbCustomSerializer&lt;Article&gt;&gt;("Articles", identity, </SPAN><SPAN class="c7 c5">art</SPAN><SPAN class=c5>);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Getting objects:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;foreach (var row in tran.SelectForward&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles").Take(10))</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//Note </SPAN><SPAN class=c5>row.Value</SPAN><SPAN class="c7 c5">&nbsp;will return us DbMJSON&lt;Article&gt;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//row.Value</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//But we need Article</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</SPAN><SPAN class="c7 c5">Article</SPAN><SPAN class=c5>&nbsp;a = row.Value.</SPAN><SPAN class="c7 c5">Get</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//Or its serialized representation</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</SPAN><SPAN class="c7 c5">string</SPAN><SPAN class=c5>&nbsp;aSerialized = row.Value.</SPAN><SPAN class="c7 c5">SerializedObject</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Multi-threading</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c6">In Dbreeze tables are always accessible for parallel READ of last committed data from multiple threads. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, while </SPAN><SPAN class=c7>one thread</SPAN><SPAN>&nbsp;is </SPAN><SPAN class=c7>writing data</SPAN><SPAN>&nbsp;into the table, </SPAN><SPAN class=c7>other threads</SPAN><SPAN>&nbsp;will </SPAN><SPAN class=c7>not </SPAN><SPAN>be </SPAN><SPAN class=c7>able </SPAN><SPAN>to </SPAN><SPAN class=c7>write </SPAN><SPAN>data in the same table (table lock), till writing thread releases its transaction, they will wait in a queue.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, while </SPAN><SPAN class=c7>one thread</SPAN><SPAN>&nbsp;is </SPAN><SPAN class=c7>writing data</SPAN><SPAN>&nbsp;into table, </SPAN><SPAN class=c7>other threads</SPAN><SPAN>&nbsp;</SPAN><SPAN class=c7>can </SPAN><SPAN>in parallel </SPAN><SPAN class=c7>read </SPAN><SPAN>already </SPAN><SPAN class=c7>committed data</SPAN><SPAN>.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, if </SPAN><SPAN class=c7>one </SPAN><SPAN>of </SPAN><SPAN class=c7>threads </SPAN><SPAN>needs, inside of the transaction, to </SPAN><SPAN class=c7>read </SPAN><SPAN>data from the tables and it wants to be sure that till the end of transaction </SPAN><SPAN class=c7>other threads</SPAN><SPAN>&nbsp;will </SPAN><SPAN class=c7>not modify </SPAN><SPAN>the data, this thread must </SPAN><SPAN class=c7>reserve tables for synchronized read</SPAN><SPAN>.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">tran.SynchronizeTables("table1", "table2");</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Transaction also has method for tables synchronization. </SPAN></P>
<P class="c1 c0"><SPAN class="c7 c5"></SPAN></P>
<P class=c0><SPAN class=c7>tran.SynchronizeTables</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This method has overloads and you can supply as parameters: List&lt;string&gt; or params string[].</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>SynchronizeTables can be run only once inside of the transaction.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>All </SPAN><SPAN class=c7>reads </SPAN><SPAN>can be divided on </SPAN><SPAN class=c7>two categories</SPAN><SPAN>&nbsp;by usage type:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>- </SPAN><SPAN class=c7>Read for reporting</SPAN></P>
<P class=c0><SPAN>- </SPAN><SPAN class=c7>Read for modification</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Based on this idea the whole multi-threaded layer is built.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Multi-threading. Read for reporting</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you think that there is no necessity to block table(s) and other threads could write data in parallel just don’t use tran.SynchronizeTables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This technique is applicable in all reporting cases. If user needs to know his bank account state, we don’t need to block the table with account information, just read account state and return it. Doesn’t matter that in this moment his account state is changing - it’s a question of a moment. If user requests his account state in 5 minutes he will get already modified account.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>There are some things which must be understood.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For example we make iteration via table Items, because someone has requested its full list.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Let’s assume that there are 100 items</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>List&lt;Item&gt; items=new List&lt;Item&gt;();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>foreach(var row in tran.SelectForward&lt;ulong, DbMJSON&lt;</SPAN><SPAN>Item&gt;</SPAN><SPAN>&gt;(“Items”))</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.Add(row.Value.Get);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//we have iterated over 50 items and in this moment other thread deleted itemId 1 and committed transaction</SPAN></P>
<P class="c0 c11"><SPAN>//Result: it’s a question of the moment this item will be added to the final List, it doesn’t matter in this case.</SPAN></P>
<P class="c1 c0 c11"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//we have iterated already 75 items and in this moment other thread deleted itemId 90 and committed transaction</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//after 89 we will get item 91 </SPAN></P>
<P class="c0 c11"><SPAN>//Result: it’s a question of the moment, item 90 will not be added to the final List, it doesn’t matter in this case.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And if you want to be sure that other threads will not modify “Items” table, while you are fetching the data, use</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.</SPAN><SPAN>SynchronizeTables(“Items”);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>If you take a row from a table always check if it exists. </SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>If your data projection is spread among many tables, first get all pieces of the data from different tables, always checking if row.Exists, in case of direct selects, and only when you have full object constructed then return it to the final projection as a ready element.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note if you have received row and it exists. It doesn’t mean that you have already acquired the value. Value will be read only when you choose property row.Value (lazy value loading). If other thread removes value in between, after you have acquired the row, but still didn’t acquired value, - then value will be returned in any case, because after removing data still stays on the disk, only keys are marked as deleted. And this behaviour for not synchronized read should be ok, because it’s a question of the moment.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>If you have acquired row and it exists, in one thread, now you are going to get the value, but in this moment other thread updates value, then you thread will receive updated value.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>In case if your thread is going to retrieve value and in this moment DBreeze.Scheme deletes table - then inside of transaction exception will be raised, controlled by try-catch integrated into using statement. </SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c2 c0"><SPAN class=c7>The same will happen if other thread executes tran.RemoveAllKeys(“your reading table”, true - withFileRecreation). Your reading thread will get exception inside of the transaction. But all will be ok if other threads removes data without file re-creation, if &nbsp;tran.RemoveAllKeys(“your reading table”, false- withFileRecreation).</SPAN></P>
<P class="c2 c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>You must use Scheme.DeleteTable, Scheme.RenameTable and tran.RemoveAllKeys with table re-creation semantically.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>Either in constructor, after engine initialization, or for temporary tables, which are used for sub-computation with the help of database, and definitely only by one thread. For tables which are under read-write pressure, better to use tran.RemoveAll(false) and then one day to compact this table by copying existing values into new table, and renaming new table to old table.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Tables copying / compaction</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Copying of the data better to make on byte[] level, it will be faster then to cast and serialize / de-serialize objects.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you had table Articles &lt;ulong, DbMJSON&lt;Atricle&gt;&gt;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Copy it like this:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>foreach(var row in tran.SelectForward(&lt;byte[],byte[]&gt;(“Articles”)))</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[],byte[]&gt;(“Articles Copy”,row.Key, row.Value);</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>then you can rename old table Scheme.RenameTable(“Articles Copy”,”</SPAN><SPAN class=c5>Articles</SPAN><SPAN class=c5>”);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>and go on to work with Article table</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>foreach(var row in tran.SelectForward(&lt;long, DbMJSON&lt;Atricle&gt;&gt;(“Articles”)))</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>...</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, we create foreach loop which reads from one table and after that writes into the other table. From HDD point ov view we make such operation:</SPAN></P>
<P class=c0><SPAN class=c7>R-W-R-W-R-W-R-W …..</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you have mechanical HDD, its head must always move between two files to complete this operation, what is not so efficient.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To increase performance of the copy procedure we need following sequence:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>R-R-R-R-W-R-R-R-R-W-R-R-R-R-W ….</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, first we read to the memory a big chunk (1K/10K/100K/1MLN of records) and then sort it by key in ascending order and insert it in bulk to the copy table.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Dictionary&lt;TKey,TValue&gt; will not be able to sort byte[]. For this we need to construct hash-string using DBreeze.Utils:</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>byte[] bt=new byte[]{0x08, 0x09};</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>string hash = bt.ToBytesString();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>then put this hash a key for Dictionary. Copy procedure with </SPAN><SPAN class=c7>R-R-R-R-W-R-R-R-R-W-R-R-R-R-W ….</SPAN></P>
<P class=c0><SPAN>sequence:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze.Utils</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>int i = 0;</SPAN></P>
<P class=c0><SPAN class=c5>int chunkSize = 100000;</SPAN></P>
<P class=c0><SPAN class=c5>Dictionary&lt;string,KeyValuePair&lt;byte[],byte[]&gt;&gt; cacheDict=new Dictionary&lt;string,KeyValuePair&lt;byte[],byte[]&gt;&gt;();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>foreach(var row in tran.SelectForward(&lt;byte[],byte[]&gt;(“Articles”)))</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cacheDict.Add(</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>row.Key.ToBytesString()</SPAN></P>
<P class="c0 c12"><SPAN class=c5>,new KeyValuePair&lt;byte[],byte[]&gt;</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>(</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.Key,</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.Value</SPAN></P>
<P class="c15 c0"><SPAN class=c5>)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i == chunkSize)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//saving sorted values to the new table in bulk</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var kvp in cacheDict.OrderBy(r=&gt;r.Key))</SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class=c5>{</SPAN></P>
<P class="c2 c0 c12 c11"><SPAN class=c5>tran.Insert&lt;byte[],byte[]&gt;(“Articles Copy”,kvp.Value.Key, kvp.Value.Value);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cacheDict.Clear();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=0;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>//If something left in cache - flush it</SPAN></P>
<P class=c0><SPAN class=c5>foreach (var kvp in cacheDict.OrderBy(r=&gt;r.Key))</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.Insert&lt;byte[],byte[]&gt;(“Articles Copy”,kvp.Value.Key, kvp.Value.Value);</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class=c0><SPAN class=c5>cacheDict.Clear();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, actually we don’t need to sort dictionary, because SelectForward from table Articles gives us already sorted values and in sorted sequence they will migrate into cache-Dictionary, so our complete code will look like this:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>int i = 0;</SPAN></P>
<P class=c0><SPAN class=c5>int chunkSize = 100000;</SPAN></P>
<P class=c0><SPAN class=c5>Dictionary&lt;byte[],byte[]&gt; cacheDict=new Dictionary&lt;byte[],byte[]&gt;();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>foreach(var row in tran.SelectForward(&lt;byte[],byte[]&gt;(“Articles”)))</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c2 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cacheDict.Add(row.Key,row.Value)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i == chunkSize)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//saving sorted values to the new table in bulk</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var kvp in cacheDict)</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>{</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>tran.Insert&lt;byte[],byte[]&gt;(“Articles Copy”,kvp.Key, kvp.Value);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cacheDict.Clear();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=0;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>//If something left in cache - flush it</SPAN></P>
<P class=c0><SPAN class=c5>foreach (var kvp in cacheDict)</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.Insert&lt;byte[],byte[]&gt;(“Articles Copy”,kvp.Key, kvp.Value);</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class=c0><SPAN class=c5>cacheDict.Clear();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Multi-threading. Read for modification</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>This technique is used when you need to get data (select) before modification (insert or update etc.):</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>private bool AddMoneyOnAccount(uint userId, decimal sum)</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>string tableUserInfo = “UserInfo” + userId;</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>tran.SynchronizeTables(tableUserInfo);</SPAN></P>
<P class="c3 c0"><SPAN class="c7 c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c3 c0"><SPAN class="c7 c5">//after SynchronizeTables, be sure that none of the other threads will write in table tableUserInfo, till the transaction will be released.</SPAN></P>
<P class="c1 c3 c0"><SPAN class="c7 c5"></SPAN></P>
<P class="c2 c3 c0"><SPAN class="c7 c5">//now we read the state of the user account</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class="c7 c5"></SPAN></P>
<P class="c3 c0"><SPAN class=c5>var row = tran.Select&lt;string,decimal&gt;(tableUserInfo ,”Account”);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>decimal accountState = 0;</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>if(row.Exists)</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accountState = row.Value;</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>//now we change the sum of the user’s account</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>accountState &nbsp;+= sum;</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>tran.Insert&lt;string,decimal&gt;(tableUserInfo, ”Account”, accountState);</SPAN></P>
<P class="c3 c0"><SPAN class="c7 c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c3 c0"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; }</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>return true;</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table WRITE, Resolving Deadlock Situation</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we write only in one table inside of transaction and for other tables use unsynchronized read, we don’t need to use </SPAN><SPAN class=c7>SynchronizeTables </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,1);</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp;</SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>But when we have inserted/updated/Removed a key in the table, DBreeze will automatically block the whole table for Write, like SynchronizeTables(“t1”) would be used, till the end of the transaction.</SPAN></P>
<P class="c1 c3 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In following example, transaction first blocks table “t1” and then “t2”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t2”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Imagine, the we have parallel thread which writes in the same tables but in other sequence:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t2”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Thread 2 has blocked table “t2”, which is going to be read by Thread 1, and Thread 1 has blocked table “t1”, which is going to be read by Thread 2.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Such situation is called deadlock. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Dbreeze automatically drops one of these threads with Deadlock Exception, and the other thread will be able successfully finish its job.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>But this is only a part of the solution. To make the program deadlock safe use in both threads </SPAN><SPAN class=c7>SynchronizeTables </SPAN><SPAN>construction:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Thread 1:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp;tran. SynchronizeTables (“t1”,”t2”);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t2”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Thread 2:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp;tran. SynchronizeTables (“t1”,”t2”);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t2”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp; &nbsp; &nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,1);</SPAN></P>
<P class="c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c7>Both threads will be executed without exceptions, one by one - absolute defence from the deadlock situation.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table WRITE, READ or SYNCHRO-READ, Data visibility scope</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In the following example we read a row from table “t1”.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c2 c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class=c5>&nbsp; &nbsp;var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We didn’t use tran.SynchronizeTables construction and we didn’t write to this table before, so we will see only last committed data, even if other thread is changing the same data in parallel, this transaction will receive only last committed data for this table.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But everything changes when transaction has a table in modification list:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,157);</SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">//Table “t1” is in modification list of this transaction and all reads from this table automatically return actual data, even before commit</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class="c7 c5"></SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">//this row.Value will return 157</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; &nbsp;var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>All reads of the table (only inside current transaction), if it’s in modification list (by SynchronizeTables or just insert/update/remove) will return modified values even if the data was not committed yet:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0 c11"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class="c7 c5"></SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">//row.Value will return 99 like other parallel threads which read</SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">this table</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; &nbsp;var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">//but this thread wants also to modify this table</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp;tran.Insert&lt;int,int&gt;(“t1”,1,117);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">//row.Value will return 117 (other threads will see 99)</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; &nbsp;var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>tran.RemoveKey(“t1”,1);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class="c7 c5">//row.Exists will be false (other threads will see 99)</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; &nbsp;var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class="c7 c5">/</SPAN><SPAN class=c5>tran.Insert&lt;int,int&gt;(“t1”,1,111);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class="c7 c5">//row.Value will return 111 (other threads will see 99)</SPAN></P>
<P class="c2 c3 c0 c11"><SPAN class=c5>var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class="c7 c5">//row.Value will return 111 (other threads will see 111)</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>var row = tran.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class="c3 c0"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Table Synchronization by PATTERN</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>Because in NoSql concept we have to have deals with many tables inside of one transaction, DBreeze has special constructions for tables locking. All these constructions are available via tran.SynchronizeTables</SPAN><SPAN class=c7>.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Again, tran.SynchronizeTables can be used only once inside of any transaction before any modification command, but can be used after read commands:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>ALLOWED:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp;</SPAN><SPAN class=c5>tran.SynchronizeTable(“t1”);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp;</SPAN><SPAN class=c5>tran.SynchronizeTable(“t1”,”t2”);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t2”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;string&gt; ids=new List&lt;string&gt;();</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach(var row in tran.SelectForward&lt;int,int&gt;(“Items”))</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ids.Add(“Article” +row.Value.ToString());</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp; </SPAN><SPAN class=c5>tran.SynchronizeTable(ids);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Note</SPAN><SPAN>, it’s possible to insert data into tables which were not synchronized by SynchronizeTable</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp;</SPAN><SPAN class=c5>tran.SynchronizeTable(“t1”);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“</SPAN><SPAN class="c7 c5">t2</SPAN><SPAN class=c5>”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>But this is better to use fo temporary tables, for avoiding deadlocks. To add uniqueness to the table name (temporary table name) add ThreadId:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{</SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp;</SPAN><SPAN class=c5>tran.SynchronizeTable(“t1”);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>string </SPAN><SPAN class="c7 c5">tempTable </SPAN><SPAN class=c5>= “temp” + tran.ManagedThreadId+”_more”;</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>//</SPAN><SPAN class="c7 c5">in case if previous process was interrupted and tempTable was not deleted</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>engine.Scheme.DeleteTable(</SPAN><SPAN class="c7 c5">tempTable</SPAN><SPAN class=c5>);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(</SPAN><SPAN class="c7 c5">tempTable</SPAN><SPAN class=c5>&nbsp;,1,99);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>//do operations with temp table.....</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp;engine.Scheme.DeleteTable(</SPAN><SPAN class="c7 c5">tempTable</SPAN><SPAN class=c5>);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>}catch(System.Exception ex)</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>{</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ex handle</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>engine.Scheme.DeleteTable(</SPAN><SPAN class="c7 c5">tempTable</SPAN><SPAN class=c5>);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>NOT ALLOWED:</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c3 c0"><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class="c3 c0"><SPAN class=c5>{ &nbsp;</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t2”,1,99);</SPAN></P>
<P class="c2 c1 c3 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp; </SPAN><SPAN class=c5>tran.SynchronizeTable(“t1”);</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Insert&lt;int,int&gt;(“t1”,1,99);</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>&nbsp; tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To synchronize tables by pattern we use special symbols:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>* - all other symbols</SPAN></P>
<P class=c0><SPAN># - all other symbols except slash, followed by slash and any other character</SPAN></P>
<P class=c0><SPAN>$ - all other symbols, excepts slash</SPAN></P>
<P class="c2 c0"><SPAN>tran.</SPAN><SPAN>SynchronizeTable(“Articles</SPAN><SPAN class=c4>*</SPAN><SPAN>”) - will mean that we block for writing all tables which start from the word Articles, like:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>&nbsp;Articles123</SPAN></P>
<P class="c2 c0"><SPAN>&nbsp;Articles231</SPAN></P>
<P class="c2 c0"><SPAN>etc.</SPAN></P>
<P class="c2 c0"><SPAN>Articles123/SubItems123/SubItems123</SPAN></P>
<P class="c2 c0"><SPAN>and so on.</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>tran.SynchronizeTable(“Articles</SPAN><SPAN class=c4>#</SPAN><SPAN>/Items</SPAN><SPAN class=c4>*</SPAN><SPAN>”) - will mean &nbsp;that we block for writing following tables, like:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Articles123/Items1257/IOo4564</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>but we don’t block</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Articles123/SubItems546</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.SynchronizeTable(“Articles</SPAN><SPAN class=c4>$</SPAN><SPAN>”) &nbsp;will mean &nbsp;that we block for writing following tables, like:</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Articles123</SPAN></P>
<P class="c2 c0"><SPAN>Articles456</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>and we don’t block</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Articles456/Items...</SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Slash can be effectively used for creating groups.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Sure we can combine patterns in one tran.SynchronizeTable command:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.SynchronizeTable(“Articles1/Items$”,”Articles#/SubItems*”, “Price1”,”Price#/Categories#/El*”) </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Non-Unique Keys</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In DBreeze tables all keys must unique.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But there are a lot of methods how to store non-unique keys.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>One of them is for every non-unique key create a separate table and store all reference to this key inside. Sometimes this approach is good.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But there is another useful approach.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Note, that DBreeze is a professional database for high performance and mission-critical applications. Developer spends a little bit more time for the Data Access Layer, but gets back very fast responses from database.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;Imagine that you have a plenty of Articles and every of it has price inside. You know that one of the requirements of your application is to show articles sorted by price. Another requirement is to show articles in price range.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>It can mean that except the table who holds articles you will need a special table where you will store prices as keys, to be able to use DBreeze SelectForwardStartFrom or SelectForwardFromTo.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Developer, while inserting one article, has to fill two tables (it’s a minimum for this example) Articles and Prices.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But how we can store prices as key - they are not unique.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Then we will make them unique.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze;</SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze.Utils;</SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze.DataTypes;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>public class Article</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id = 0;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = String.Empty;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price = 0f;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public uint Id { get; set; }</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public string Name { get; set; }</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public float Price { get; set; }</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>public void Example_NonUniqueKey()</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.Schema.DeleteTable("Articles");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint id=0;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Article art = new Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = "Notebook",</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price = 100.0f</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id++;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", id, art);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] idAsByte = id.To_4_bytes_array_BigEndian();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] priceKey = art.Price.To_4_bytes_array_BigEndian().Concat(idAsByte);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("{0}; Id: {1}; IdByte[]: {2}; btPriceKey: {3}", art.Name, id, idAsByte.ToBytesString(""), priceKey.ToBytesString(""));</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[], byte[]&gt;("Prices", priceKey, null);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;art = new Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = "Keyboard",</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price = 10.0f</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id++;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", id, art);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idAsByte = id.To_4_bytes_array_BigEndian();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;priceKey = art.Price.To_4_bytes_array_BigEndian().Concat(idAsByte);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("{0}; Id: {1}; IdByte[]: {2}; btPriceKey: {3}", art.Name, id, idAsByte.ToBytesString(""), priceKey.ToBytesString(""));</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[], byte[]&gt;("Prices", priceKey, null);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;art = new Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = "Mouse",</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price = 10.0f</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id++;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", id, art);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idAsByte = id.To_4_bytes_array_BigEndian();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;priceKey = art.Price.To_4_bytes_array_BigEndian().Concat(idAsByte);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("{0}; Id: {1}; IdByte[]: {2}; btPriceKey: {3}", art.Name, id, idAsByte.ToBytesString(""), priceKey.ToBytesString(""));</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[], byte[]&gt;("Prices", priceKey, null);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;art = new Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = "Monitor",</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price = 200.0f</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id++;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", id, art);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idAsByte = id.To_4_bytes_array_BigEndian();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;priceKey = art.Price.To_4_bytes_array_BigEndian().Concat(idAsByte);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("{0}; Id: {1}; IdByte[]: {2}; btPriceKey: {3}", art.Name, id, idAsByte.ToBytesString(""), priceKey.ToBytesString(""));</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[], byte[]&gt;("Prices", priceKey, null);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this article was added later and not reflected in the post explanation</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;art = new Article()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name = "MousePad",</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price = 3.0f</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id++;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", id, art);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idAsByte = id.To_4_bytes_array_BigEndian();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;priceKey = art.Price.To_4_bytes_array_BigEndian().Concat(idAsByte);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("{0}; Id: {1}; IdByte[]: {2}; btPriceKey: {3}", art.Name, id, idAsByte.ToBytesString(""), priceKey.ToBytesString(""));</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[], byte[]&gt;("Prices", priceKey, null);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("***********************************************");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Fetching data &gt;=</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//We are intereste here in Articles with the cost &gt;= 10</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float price = 10f;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint fakeId = 0;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] searchKey = price.To_4_bytes_array_BigEndian().Concat(fakeId.To_4_bytes_array_BigEndian());</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Article art=null;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var row in tran.SelectForwardStartFrom&lt;byte[], byte[]&gt;("Prices", searchKey, true))</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Found key: {0};",row.Key.ToBytesString(""));</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var artRow = tran.Select&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", row.Key.Substring(4, 4).To_UInt32_BigEndian());</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (artRow.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;art = artRow.Value.Get;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Articel: {0}; Price: {1}", art.Name, art.Price);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("***********************************************");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Fetching data &gt;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//We are intereste here in Articles with the cost &gt; 10</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float price = 10f;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint fakeId = UInt32.MaxValue;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] searchKey = price.To_4_bytes_array_BigEndian().Concat(fakeId.To_4_bytes_array_BigEndian());</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Article art = null;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var row in tran.SelectForwardStartFrom&lt;byte[], byte[]&gt;("Prices", searchKey, true))</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Found key: {0};", row.Key.ToBytesString(""));</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var artRow = tran.Select&lt;uint, DbMJSON&lt;Article&gt;&gt;("Articles", row.Key.Substring(4, 4).To_UInt32_BigEndian());</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (artRow.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;art = artRow.Value.Get;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Articel: {0}; Price: {1}", art.Name, art.Price);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Every article when is inserted to Articles table receives its unique id ot type uint:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Articles&lt;uint,DbMJSON&lt;Article&gt;&gt;(“Articles”)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You remember that in namespace DBreeze.Utils there are a lot of extension for converting different data types to byte[] and back. We can convert decimals, doubles, floats, integers etc. to byte[] and back.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Article price is float in our example and can be converted to byte[4] (sortable byte array from DBreeze.Utils, System.BitConverter will not give you such results).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>As you see we had 4 articles 2 of them had the same price. </SPAN></P>
<P class=c0><SPAN>We achieve uniqueness of the price on the byte level by concatenating two byte array.</SPAN></P>
<P class=c0><SPAN>First part is a price converted to byte array (for Article </SPAN><SPAN class=c5>Keyboard</SPAN><SPAN>):</SPAN></P>
<P class=c0><SPAN>float 10.0f -&gt; AE-0F-42-40</SPAN></P>
<P class="c2 c0"><SPAN>Second part is uint Id from table Articles converted to byte array (for Article </SPAN><SPAN class=c5>Keyboard</SPAN><SPAN>):</SPAN></P>
<P class=c0><SPAN>uint 2 -&gt; 00-00-00-02</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>when we concatenate both byte arrays for every article we will have such result:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Notebook; Id: 1; btPriceKey: AF-0F-42-40-00-00-00-01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//100f</SPAN></P>
<P class=c0><SPAN>Keyboard; Id: 2; btPriceKey: AE-0F-42-40-00-00-00-02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//10f</SPAN></P>
<P class=c0><SPAN>Mouse; Id: 3; btPriceKey: AE-0F-42-40-00-00-00-03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//10f</SPAN></P>
<P class=c0><SPAN>Monitor; Id: 4; btPriceKey: AF-1E-84-80-00-00-00-04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//200f</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>That’s all exactly these final byte arrays we insert into table prices.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now fetching data</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Select Forward and Backward from table Prices will give you already sorted by price results.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>More interesting is to get All prices starting from 10f.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For this we will use tran.SelectForwardStartFrom(“Prices”,btKey,true);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>we need to get btKey.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We take our desirable 10f and convert to byte[]</SPAN></P>
<P class=c0><SPAN>float findPrice = 10f;</SPAN></P>
<P class=c0><SPAN>byte[] btKey = findPrice.To_4_bytes_array_BigEndian();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>then we need to concatenate with the btKey full article id and here is a trick:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>uint id = 0;</SPAN></P>
<P class=c0><SPAN>btKey = btKey.Concat(id.To_4_bytes_array_BigEndian())</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will give us such btKey:</SPAN></P>
<P class=c0><SPAN>AE-0F-42-40-00-00-00-00 </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>if we use it in tran.SelectForwardStartFrom(“Prices”,btKey,true);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>we will receive all prices &gt;= 10f.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>uint id = UInt32.MaxValue;</SPAN></P>
<P class=c0><SPAN>btKey = btKey.Concat(id.To_4_bytes_array_BigEndian())</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>will give us such btKey:</SPAN></P>
<P class=c0><SPAN>AE-0F-42-40-FF-FF-FF-FF</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>applying such key in tran.SelectForwardStartFrom(“Prices”,btKey,true);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>we will receive price only &gt; 10f.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN>Sure when you got the key from value price (it’s byte[]), you can make row.Value.Substring(4,4).To_UInt32_BigEndian() - receive you uint id from table Articles and retrieve value from table Articles by this key.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120521] </SPAN></P>
<P class=c0><SPAN>&nbsp;</SPAN></P>
<P class=c0><SPAN class="c7 c13">Fractal tables structure.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We call it with a fancy word “fractal”, because it has self-similar structure.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Actually, it’s an ability to store in any kind of a value (of a Key/Value table) from 1 to N other tables + extra data. And in any kind of a nested table keys values other from 1 to N tables + extra data and so on, till you resources let you do that. Such multi-dimensional storage concept.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>It can also mean that in one value we can store object of any complexity kind. Every property of this object which can be represented as a table (List or Dictionary) inherits all possibilities of the master table. We can make again favorite operations like Forward, Backward Skip, Remove, Add etc. and the same with sub-nested tables and sub-sub....-sub nested tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>To insert a table in a value we need 64 bytes - it’s a size of table root. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Table "t1"</SPAN></P>
<P class=c0><SPAN>&nbsp;Key &nbsp;| Value</SPAN></P>
<P class=c0><SPAN>&nbsp; 1 &nbsp; | &nbsp;/...64 byte..../ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/...64 byte..../ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/...64 byte..../</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&lt;int&gt;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&lt;string&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/...64 byte..../ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a5 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/...64 byte..../ /...64 byte..../</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/...64 byte....//...64 byte..../ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b6 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t7 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h8 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long</SPAN></P>
<P class=c0><SPAN>&nbsp; 2 &nbsp; | &nbsp;/...64 byte..../</SPAN></P>
<P class=c0><SPAN>&nbsp; 3 &nbsp; | &nbsp;/...64 byte....//...64 byte..../ extra data /...64 byte..../ extra data /...64 byte..../</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>Note,</SPAN><SPAN>&nbsp;it’s not possible to copy the table which has in values nested tables with the &nbsp;techniques described before (simple bytes copying). But it is possible to automate this process, because the table root has a mark “dbreeze.tiesky.com” always starting at the same point from table root start, also the root length is fixed with 64 bytes, so one day we will make this recursive copy function.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, we are still thinking about the methods names which we use while fetching nested tables and we know that the time will place correct emphasis here also.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Fractal tables structure. Getting Started</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Every operation starts from the master table. Master table is a table which is stored in the Scheme and you perfectly know its name.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.Insert&lt;int,string&gt;(“t1”,1,”Hello”);</SPAN></P>
<P class=c0><SPAN>tran.Insert&lt;int,string&gt;(“t1/Points”,1,”HelloAgain”);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>“t1” and “t1/Points” - are master tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, lets assume we have master table with the name “t1”. Keys of this table are of integer type. Values can be different.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, string&gt;("t1", 1, "hello");</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, byte[]&gt;("t1", 2, new byte[] { 1, 2, 3 });</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, decimal&gt;("t1", 3, 324.34M);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception ex)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(ex.ToString());</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>If you know what is stored under different keys you can always correctly fetch the values, on the lowest level they are always byte[] - byte array.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To insert a table we have designed new method</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>tran.InsertTable&lt;int&gt;("t1", 4, 0);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>you need to supply one type for key resolving, value will be automatically resolved as byte array. As parameters you need to supply master table name, key (4 in our example) and table index. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>As you remember we can put more then 1 table in the value and every of it will reside 64 bytes.</SPAN></P>
<P class=c0><SPAN>So, if index = 0 then table will reside value bytes from 0-63, if index = 1 then table will reside value bytes from 64-127 etc....</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In between you can put your own values, just remember not to overlap nested tables roots.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Again, we can say</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.InsertTable&lt;int&gt;("t1", 4, 0);</SPAN></P>
<P class=c0><SPAN>tran.InsertPart&lt;int, int&gt;("t1", 4, 587, 64);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Key 4 will have 64 bytes of a table and then 4 reserved bytes for the value 587. You can work separately with them.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, method </SPAN><SPAN class=c7>InsertTable </SPAN><SPAN>gives us extra load telling that we want to insert/change/modify. If the </SPAN><SPAN class=c7>table </SPAN><SPAN>didn’t exist in that place it will be </SPAN><SPAN class=c7>automatically created</SPAN><SPAN>. Also Insert Table will notify the system that thread, who is using it, tries to modify table “t1”, that’s why all necessary techniques like tran.SynchronizeTables, if you modify more then one master table, must be used. They are described in previous chapters.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have another method</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>tran.SelectTable&lt;int&gt;("t1", 4, 0);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In opposite to InsertTable if table is not found it will not be created.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, method </SPAN><SPAN class=c7>SelectTable </SPAN><SPAN>will not create table if it doesn’t exist and this method is recommended for </SPAN><SPAN class=c7>READING THREADS. </SPAN><SPAN>But also can be used by WRITING threads just to get the table without its creation.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>Note, </SPAN><SPAN>tran.</SPAN><SPAN class=c7>InsertTable</SPAN><SPAN>&nbsp;and </SPAN><SPAN class=c7>SelectTable </SPAN><SPAN>always return value of type </SPAN><SPAN class=c7>DBreeze.DataTypes.NestedTable</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>NestedTable </SPAN><SPAN>repeats by functionality Transaction class in the scope of table operations. You will find there all well known methods: Select SelectForward Backward, Insert, InsertPart, RemoveKey, RemoveAll etc.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>First difference is that you don’t need to supply table name as parameter.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Key &nbsp; Value</SPAN></P>
<P class=c0><SPAN>1</SPAN></P>
<P class=c0><SPAN>2</SPAN></P>
<P class=c0><SPAN>3</SPAN></P>
<P class=c0><SPAN>4 &nbsp; &nbsp; &nbsp; &nbsp;/*....64 byte...table*/ /*4 bytes integer*/</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Key &nbsp; Value</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hi1</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hi2</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hi3</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To build up such structure we do following code:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;tran</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.InsertTable&lt;int&gt;("t1", 4, 0)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert&lt;int, string&gt;(1, "Hi1")</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert&lt;int, string&gt;(2, "Hi2")</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert&lt;int, string&gt;(3, "Hi3");</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This “functional programming” technique is possible due to returns of Insert - It returns the underlying NestedTable.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To read the data we do following:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;tran</SPAN></P>
<P class="c3 c0 c11"><SPAN>.SelectTable&lt;int&gt;("t1", 4, 0)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Select&lt;int, string&gt;(1)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.PrintOut();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We will receive “Hi1”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>PrintOut is a small “console out” helper for checking the content.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Lets iterate</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>&nbsp;foreach (var row in tran</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.SelectTable&lt;int&gt;("t1", 4, 0)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.SelectForward&lt;int, string&gt;()</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.PrintOut();</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note, if you try to Insert into nested table after master-SelectTable you will receive an exception. Inserting (Removing, changing - etc all modifications) into all nested tables generations is allowed only starting from master- InsertTable method.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>Let’s try more complex structure</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>Key &nbsp; Value</SPAN></P>
<P class=c0><SPAN>1</SPAN></P>
<P class=c0><SPAN>2</SPAN></P>
<P class=c0><SPAN>3</SPAN></P>
<P class=c0><SPAN>4 &nbsp; &nbsp; &nbsp; &nbsp;/*....64 byte...table*/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Key &nbsp; Value</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hi1</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/*....64 byte...table*/ &nbsp; &nbsp;/*....64 byte...table*/ </SPAN></P>
<P class="c3 c0 c11"><SPAN>Key &nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key &nbsp;Value</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp;Xi1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; Piar7</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp;Xi2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; Piar8</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hi3</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>&nbsp;</SPAN><SPAN class=c5>var horizontal = </SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>tran</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.InsertTable&lt;int&gt;("t1", 4, 0);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horizontal.Insert&lt;int, string&gt;(1, "Hi1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horizontal</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">.GetTable&lt;int&gt;(2, 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//we use it to access next table genearation</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert(1, "Xi1")</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert(2, "Xi2");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horizontal</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">.GetTable&lt;int&gt;(2, 1)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert(7, "Piar7")</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Insert(8, "Piar8");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horizontal.Insert&lt;int, string&gt;(3, "Hi1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c7>//Here all values for all nested tables will be committed</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c7>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>//Fetching value</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SelectTable&lt;int&gt;("t1", 4, 0)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.GetTable&lt;int&gt;(2, 1)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Select&lt;int, string&gt;(7)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.PrintOut();</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c5"></SPAN></P>
<P class=c0><SPAN class="c7 c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c7>//Return will be “Piar7”</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, there is no separate Commit or Rollback of the nested tables they are done via master table Commit or Rollback.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120525]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Select returns &nbsp;DBreeze.DataTypes.Row</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This </SPAN><SPAN class=c7>Row </SPAN><SPAN>we know from previous examples, but now it’s enhanced with new method GetTable(uint tableIndex), where you can get nested table stored inside of this row by tableIndex. It works for master and for nested tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.InsertTable&lt;int&gt;("t1", 1, 1)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Insert&lt;uint, string&gt;(1, "Test1")</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .Insert&lt;uint, string&gt;(2, "Test2")</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .Insert&lt;uint, string&gt;(3, "Test3");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //foreach (var row in tran.SelectTable("t1", 1, 1)) &nbsp;- also possible but...</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var row in tran.SelectForward&lt;int,byte[]&gt;("t1"))</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var r1 in row.GetTable(1).SelectForward&lt;uint, string&gt;())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r1.PrintOut();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>//Result will be </SPAN></P>
<P class=c0><SPAN>1; “Test1”</SPAN></P>
<P class=c0><SPAN>2; “Test2”</SPAN></P>
<P class=c0><SPAN>3; “Test3”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class="c7 c13">InsertDictionary. SelectDictionary. InsertHashSet. SelectHashSet</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>We have created extra insert and select statements for master table and nested table to support direct casts of the DBreeze tables as a C# Dictionary and HashSet (list of unique keys).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;Dictionary&lt;uint,string&gt; _d=new Dictionary&lt;uint,string&gt;();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_d.Add(10, "Hello, my friends");</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_d.Add(11, "Sehr gut!");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&lt;uint, string&gt; _b = null;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Insert into Master Table Row</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.InsertDictionary&lt;int, uint, string&gt;("t1", 10, _d, 0,true);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Insert into Nested Table Dictionary</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.InsertTable&lt;int&gt;("t1",15,0)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.InsertDictionary&lt;int, uint, string&gt;(10, _d, 0,true);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Select from master table</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_b = tran.SelectDictionary&lt;int, uint, string&gt;("t1", 10, 0);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_b = tran.SelectTable&lt;int&gt;("t1",15,0)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.SelectDictionary&lt;int, uint, string&gt;(10, 0);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c6>tran.InsertDictionary&lt;int, uint, string&gt;("t1", 10, _d, 0,true); </SPAN></P>
<P class="c1 c0"><SPAN class=c6></SPAN></P>
<P class=c0><SPAN>will create following structure:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>“t1”</SPAN></P>
<P class=c0><SPAN>Key&lt;int&gt; &nbsp; &nbsp;Value&lt;byte[]&gt;</SPAN></P>
<P class=c0><SPAN>1</SPAN></P>
<P class=c0><SPAN>2</SPAN></P>
<P class=c0><SPAN>..</SPAN></P>
<P class=c0><SPAN>10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*0-63 bytes new table*/</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Key&lt;uint&gt; &nbsp; &nbsp; Value&lt;string&gt;</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“Hello, my friends”</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“Sehr gut!”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c6>tran</SPAN></P>
<P class="c0 c11"><SPAN class=c6>.InsertTable&lt;int&gt;("t1",15,0)</SPAN></P>
<P class=c0><SPAN class=c6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .InsertDictionary&lt;int, uint, string&gt;(10, _d, 0,true);</SPAN></P>
<P class="c1 c0"><SPAN class=c6></SPAN></P>
<P class=c0><SPAN>will create following structure:</SPAN></P>
<P class="c1 c0"><SPAN class=c6></SPAN></P>
<P class=c0><SPAN>“t1”</SPAN></P>
<P class=c0><SPAN>Key&lt;int&gt; &nbsp; &nbsp;Value&lt;byte[]&gt;</SPAN></P>
<P class=c0><SPAN>1</SPAN></P>
<P class=c0><SPAN>2</SPAN></P>
<P class=c0><SPAN>..</SPAN></P>
<P class=c0><SPAN>15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*0-63 bytes new table*/</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Key&lt;int&gt; &nbsp; &nbsp; Value&lt;byte[]&gt;</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/*0-63 bytes new table*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c15 c0 c11"><SPAN>Key&lt;uint&gt; &nbsp; &nbsp; Value&lt;string&gt;</SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“Hello, my friends”</SPAN></P>
<P class="c3 c0 c11"><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“Sehr gut!”</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Select will be used to get these values, Hashset has the same semantic.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, there is one important flag in InsertDictionary and InsertHashSet. It’s last parameter bool withValuesRemove. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you supplied before Dictionary with keys 1,2,3....commit......then next time you supply Dictionary with values 2,3,4 </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>if withValuesRemove = true</SPAN></P>
<P class=c0><SPAN>&nbsp; then in db will stay keys 2,3,4</SPAN></P>
<P class=c0><SPAN>if withValuesRemove = false</SPAN></P>
<P class=c0><SPAN>&nbsp; then in db will stay keys 1,2,3,4</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>These structures designed as help functions for:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>- The quick method to store a set of keys/values into the nested tables from Dictionary or HashSet (InsertDictionary(....,false)).</SPAN></P>
<P class=c0><SPAN>- Help functions for small Dictionaries/HashSets to be stored and Selected with automatic removal and update (InsertDictionary(....,true)).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>- Abillity to get the full table of any Key/Value type as Dictionary or HashSet - right in memory.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120526]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have also added Insert/Select Dictionary/HashSet for the tables themselves (not just moved by levels)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We can make following:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>inserting right into t1 table values represented as Dictionary:</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c5>tran.InsertDictionary&lt;int, int&gt;("t1", new Dictionary&lt;int, int&gt;(), false);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>inserting into t1 row 1 a table which locates from 0 byte of row a Dictionary:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c5>tran.InsertTable&lt;int&gt;("t1", 1, 0).InsertDictionary&lt;uint, uint&gt;(new Dictionary&lt;uint, uint&gt;(), false);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>Corresponding selects:</SPAN></P>
<P class=c0><SPAN class=c5>tran.SelectDictionary&lt;int, int&gt;("t1");</SPAN></P>
<P class=c0><SPAN class=c5>tran.SelectTable&lt;int&gt;("t1", 1, 0).SelectDictionary&lt;uint, uint&gt;();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>The same for HashSets.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120529]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Nested tables memory management.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>We have a situation of memory growth in case if we use lot’s of nested tables inside of one transaction. Support of a table takes a memory amount.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Master table and nested into it tables share the same physical file. Current engine automatically disposes master table and all nested tables when transaction (working with master table) is finished. But only in case when parallel threads don’t read from the same table in the same time. Master table and nested into it tables will be disposed together with the last working with this table transaction. If we write into the table once per 7 seconds and read once per 2 seconds, definitely this table will be able to free residing memory in-between.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Some more situations. For example we insert data in such manner:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 100000; i++)</SPAN></P>
<P class="c0 c11"><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.InsertTable&lt;int&gt;("t1", i, 1)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; .Insert&lt;uint, uint&gt;(1, 1);</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Really bad case for the memory. In this case we have to open 100000+1(master) tables and hold them in memory till tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In our tests used memory has grown up from 30MB (basic run of a test program) up to 350MB...after transaction was finished the process size didn’t change, but those 320MB were marked to be collected by .NET Garbage Collector, so calling GC.Collect (or using the process further) brings back to 30MB.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And for now it’s hard to find out the ways how to avoid this memory growth. It’s not so critical when you insert in small chunks (100 records). So you must remember about that.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Another case:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Looks even more interesting. When we select data</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 100000; i++)</SPAN></P>
<P class="c0 c11"><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var row = tran.SelectTable&lt;int&gt;("t1", i, 1)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; .Select&lt;uint, uint&gt;(1, 1);</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(row.Exists)</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c0 c12 c11"><SPAN>//..do</SPAN></P>
<P class="c0 c12"><SPAN>}</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Here, after every loop iteration we don’t need any more used table, but it still stays in memory and make it growing. In this example memory has grown up from 30MB up to 135MB, sure if you select more records it will need more memory resource.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Exactly for such case we had to integrate table.Close method.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To use Close, we need a variable for accessing this table. Our code will look like this now:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN>{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var row in tran.SelectForward&lt;int, byte[]&gt;("t1"))</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c7>var tbl = row.GetTable(1);</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!tbl.Select&lt;uint, uint&gt;(1).Exists)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("not");</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c7>tbl.CloseTable();</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now memory holds the “necessary level”.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, When we call NestedTable.Close, method, we want to close current table and all nested in it tables. Every master-table InsertTable or SelectTable (and nestedTable.GetTable) increase “open quantity” variable by 1, every CloseTable decreses value by 1, when value is &nbsp;less then 1, then the table with all nested in it tables will be closed. </SPAN></P>
<P class=c0><SPAN>If we forget to close table then it will be open till all operations with master table are finished and automatic dispose works.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Note, NestedTable.Dispose calls CloseTable automatically,</SPAN></P>
<P class=c0><SPAN>so we can make:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=c7>using(var tbl = row.GetTable(1))</SPAN></P>
<P class="c0 c11"><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!tbl.Select&lt;uint, uint&gt;(1).Exists)</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("not");</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c0 c11"><SPAN>}</SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Rules.</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class=c7>- Don’t close the table before you Commit or Rollback it. </SPAN></P>
<P class=c0><SPAN class=c7>- Transaction end will close master and nested tables automatically if no other threads are working with it, probably parallel thread will close it after finish.</SPAN></P>
<P class=c0><SPAN class=c7>- Close table instances manually if operations with the table are very intensive and there is no chance that it will be closed automatically.</SPAN></P>
<P class=c0><SPAN class=c7>- Control InsertTable the same way as SelectTable.</SPAN></P>
<P class=c0><SPAN class=c7>- It’s possible to close tables of all nesting generations, depending upon your table structure. They will be closed starting from called generation.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This chapter is on the level of the experiment. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Secondary Index. Direct key select.</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN>Here we present another experimental approach.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we need to support other indices then our table key, where we store our objects we need to create other tables where keys will be secondary index etc. In secondary index table we can store direct pointer the first table with the object in contrast with the key.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>When we insert or change the key we have an ability to obtain its file pointer:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[] ptr =null;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", 12, 17, out ptr);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SelectDirect&lt;int, int&gt;("t1", ptr).PrintOut();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.ChangeKey&lt;int&gt;("t1", 12, 15,out ptr);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SelectDirect&lt;int, int&gt;("t1", ptr).PrintOut();</SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>then we can get the value by pointer economizing time for the search of the first table key.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, when we update primary-table, who holds full information about the object, it’s pointer can be moved, that’s why our DAL must update value (pointer to the primary table key) in the secondary table also. When we delete from primary table, we must delete in the same transaction from secondary index table also.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>The same we can make inside of nested tables. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Note, for nested tables SelectDirect must be used exactly from the table where you are searching information to avoid collisions:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>byte[] ptr =null;</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using(var tbl = tran.InsertTable&lt;int&gt;("t3", 15, 0))</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp;tbl.Insert&lt;int, int&gt;(12, 17, out ptr);</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>using(var tbl = tran.SelectTable&lt;int&gt;("t3", 15, 0))</SPAN></P>
<P class=c0><SPAN>{</SPAN></P>
<P class="c3 c0"><SPAN>var row = tbl.SelectDirect&lt;int, int&gt;(ptr);</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;row.PrintOut();</SPAN></P>
<P class="c1 c3 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, we can get pointer to the value inside of </SPAN><SPAN class=c7>Insert</SPAN><SPAN>, </SPAN><SPAN class=c7>InsertPart </SPAN><SPAN>and </SPAN><SPAN class=c7>ChangeKey </SPAN><SPAN>for primary and nested tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120601]</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class="c7 c13">Dynamic-length data blocks and binding them to Row.Column.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Inside of the table we have key and value. If to think about the value as row with columns, that gives us ability to store in one row independent data types, which we can access using Row.GetValuePart(uint startIndex, uint length) and everything seems to be good, when our data types have fixed length. But sometimes we need to store inside of columns dynamic-length data structures. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For this we have developed following method inside of the transaction class:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>public byte[] InsertDataBlock(string tableName, byte[] initialPointer, byte[] data)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Data blocks live in parallel with the table itself and inherit the same data visibility behaviour for different threads like other structures. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Nested tables also have InsertDataBlock method.</SPAN></P>
<P class=c0><SPAN class=c7>Note</SPAN><SPAN>, InsertDataBlock always return byte[] of the same length - 16 bytes - it’s a definition of the stored value, because returned value length is fixed we can use it as column inside of a Row.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note, </SPAN><SPAN>if 2 parameter initialPointer is NULL then new data block will be created for the table, if not NULL it can mean that such data block already exists and DBreeze will try to overwrite it.</SPAN></P>
<P class=c0><SPAN>Note, data-blocks obey transaction rules, so till you commit “updated” data-block, parallel reading threads will continue to see its last-committed value. We can also rollback changes.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>After we insert data-block we want to store its pointer inside of a row, to have an ability to get it later:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>byte[] dataBlockPtr = tran.InsertDataBlock("t1", null, new byte[] { 1, 2, 3 });</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>here we have received data-block pointer and we want to store this pointer in t1 row</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 17, dataBlock, 10);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>we have stored pointer to the data-block inside of “t1” key (17) starting from index 10, pointer has always fixed length 16 byte, starting from index 26 we can go on to store other values.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now we want to retrieve the data back:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>It’s possible via Row object:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>var row = tran.Select&lt;int, byte[]&gt;("t1", 17);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] res = row.</SPAN><SPAN class="c7 c5">GetDataBlock</SPAN><SPAN class=c5>(10);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>Note, Data-Block can store null value.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c6>Updated:</SPAN></P>
<P class=c0><SPAN class=c6>Also, we can now directly get DataBlocks from transaction:</SPAN></P>
<P class=c0><SPAN class=c6>//When datablock is saved in master table</SPAN></P>
<P class=c0><SPAN class=c6>tran.SelectDataBlock("t1",dataBlockPointer); </SPAN></P>
<P class=c0><SPAN class=c6>//When datablock is saved in nested table</SPAN></P>
<P class=c0><SPAN class=c6>tran.SelectTable&lt;int&gt;("t1",1,0).SelectDataBlock(dataBlockPointer)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we want to store link to the data-block inside of nested table row, we must make it via Nested Table method:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>var tbl = tran.InsertTable&lt;int&gt;("t1", 18, 0);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>byte[] dbp = tbl.InsertDataBlock(null, new byte[] { 1, 2, 3 });</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tbl.InsertPart&lt;int, byte[]&gt;(19, dbp, 10);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tbl.CloseTable();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tbl = tran.SelectTable&lt;int&gt;("t1", 18, 0);</SPAN></P>
<P class=c0><SPAN class=c5>var row = tbl.Select&lt;int, byte[]&gt;(19);</SPAN></P>
<P class=c0><SPAN class=c5>byte[] fr = row.GetDataBlock(10);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>if (fr == null)</SPAN></P>
<P class="c0 c11"><SPAN class=c5>Console.WriteLine("T1 NULL");</SPAN></P>
<P class=c0><SPAN class=c5>else</SPAN></P>
<P class="c0 c11"><SPAN class=c5>Console.WriteLine("T1 " + fr.ToBytesString());</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>System understands empty pointers to the data-block. In following example we try to get not-existing data-block, then update it and write pointer back:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>var row = tran.Select&lt;int, byte[]&gt;("t1", 17);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>byte[] dataBlock = row.GetDataBlock(10);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>dataBlock = tran.InsertDataBlock("t1", dataBlock, new byte[] { 1, 2, 3, 7, 8 });</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.InsertPart&lt;int, byte[]&gt;("t1", 17, dataBlock, 10);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class="c7 c13">Hash Functions of common usage. Fast access to long strings and byte arrays.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze search-trie is a variation of radix trie, optimized by all parameters - </SPAN><SPAN class=c7>© Liana-Trie</SPAN><SPAN>. So, if we have keys of type int (4 bytes), we will need from 1 up to 4 HDD hits to get random key (we don’t talk about HDD possible problems and OS file system fragmentations here). If we have keys of type long (8 bytes) we will need from 1 up to 8 hits, depending upon keys quantity and character. If we store longer byte arrays, we will need from 1 up to max-length of the biggest key hits. If we store in one table 4 such string keys:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>key1: </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://google.com/hi&amp;sa=D&amp;usg=AFQjCNHGLd6NbasL1EsqV5QTbT6Li29ouw">http://google.com/hi</A></SPAN></P>
<P class=c0><SPAN>key2: </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://google.com/hi&amp;sa=D&amp;usg=AFQjCNHGLd6NbasL1EsqV5QTbT6Li29ouw">http://google.com/bye</A></SPAN></P>
<P class=c0><SPAN>key3: </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://dbreeze.tiesky.com&amp;sa=D&amp;usg=AFQjCNETavWyvr9IXC-AWghR4__Pw5qJhg">http://dbreeze.tiesky.com</A></SPAN></P>
<P class=c0><SPAN>key4: abrakadabra</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>to get randomly key1 we will need </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://google.com/hi&amp;sa=D&amp;usg=AFQjCNHGLd6NbasL1EsqV5QTbT6Li29ouw">http://google.com/</A></SPAN><SPAN>h - 19 hits</SPAN></P>
<P class=c0><SPAN>to get randomly key2 we will need </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://google.com/hi&amp;sa=D&amp;usg=AFQjCNHGLd6NbasL1EsqV5QTbT6Li29ouw">http://google.com/</A></SPAN><SPAN>b - 19 hits</SPAN></P>
<P class=c0><SPAN>to get randomly key3 we will need </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://google.com/hi&amp;sa=D&amp;usg=AFQjCNHGLd6NbasL1EsqV5QTbT6Li29ouw">http://</A></SPAN><SPAN>d - 8 hits</SPAN></P>
<P class=c0><SPAN>to get randomly key4 we will need only 1 hit</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>(after you find a key in range selects, searching of others, inside of iteration will work fast)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, if we need to use StartsWith, or we need sorting of such table, we have to store keys like they are.</SPAN></P>
<P class=c0><SPAN>But if we need just random access to such keys, the best approach will be to store not the full keys but only their 4/8 or 16 bytes HASH-CODES. Also, hashed keys and values with direct physical pointers, can represent secondary index. For example, in first table we store keys, like they are, with the content and in second table we store hashes of those keys and physical pointers to the first table. Now we can get sorted view and have fastest random access (from 1 up to 8 hits, if hash is of 8 bytes).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Hashes can have collisions. We have integrated into DBreeze sources MurMurHash3 algorithm (which returns back 4 bytes hash) and added two more functions to get 8 bytes and 16 bytes hash code. We recommend to use those 8 bytes or 16 byt</SPAN><SPAN>e</SPAN><SPAN>s functions to stay </SPAN><SPAN>collision-safe with a very high probability</SPAN><SPAN>. If you need 1000% guarantee, use nested table under every hash and store in it real key (or keys in case of collisions), for checking or some kind of other technique, like serialized list of keys with the same hash code.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_64 - 8 byte - returns ulong</SPAN></P>
<P class=c0><SPAN>and</SPAN></P>
<P class=c0><SPAN>DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_128 - 16 byte - return byte[]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120628]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Row has property LinkToValue (actually it’s a link to Key/Value), for getting direct link to the row and using it together with SelectDirect. All links (pointers to key/value pairs) now return fixed 8 bytes and can be stored as virtual column in rows.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Also, we can now directly get DataBlocks from transaction:</SPAN></P>
<P class=c0><SPAN>//When datablock is saved in master table</SPAN></P>
<P class=c0><SPAN>tran.SelectDataBlock("t1",dataBlockPointer); </SPAN></P>
<P class=c0><SPAN>//When datablock is saved in nested table</SPAN></P>
<P class=c0><SPAN>tran.SelectTable&lt;int&gt;("t1",1,0).SelectDataBlock(dataBlockPointer)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120905]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Integrated incremental database backup ability. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To make it working instantiate dbreeze like this:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreezeConfiguration conf = new DBreezeConfiguration()</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c3 c0 c11"><SPAN>DBreezeDataFolderName = @"D:\temp\DBreezeTest\DBR1",</SPAN></P>
<P class="c1 c3 c0 c11"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backup = new Backup()</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BackupFolderName = @"D:\temp\DBreezeTest\DBR1\Bup",</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IncrementalBackupFileIntervalMin = 30</SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine = new DBreezeEngine(conf);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If Backup object is not included in configuration or DBreeze is instantiated without configuration, like it was before, incremental backup will be switched off. Sure, there is still DBreeze constructor without configuration parameter at all.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you have existing databases you can make its full copy (“snapshot”) and start to continue to work with the incremental backup option switched on. Backup will create once per “IncrementalBackupFileIntervalMin “ a new file (old files are released and can be copied out and deleted). Current backup file is always locked by dbreeze. You have to specify folder for dbreeze incremental backup files “BackupFolderName”. That’s all.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If you start new database with incremental backup option, then later you will be able to recreate the whole db from backup files, if you have started from a “snapshot” then backup files can bring your “snapshot“ to current db state.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You can restore backup in the folder where your snapshot resides or, if incremental backup was switched on from the beginning, into the empty folder.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Example of backup restoration is shown in VisualTester - satellite project to DBreeze solution, under button “RestoreBackup”.<BR></SPAN></P>
<P class=c0><SPAN>Switched on incremental backup option brings to Write speed decrease, Read speed is untouched.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Inserting one million of integers without backup option - 9 sec with option - 17 sec.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20120922]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>!!!!!!!!!!!!!!!!!!!!!!!! &nbsp;IMPORTANT WHO USED DATABASE TILL THIS PERIOD</SPAN></P>
<P class=c0><SPAN class=c7>!!!!!!!!!!!!!!!!!!!!!!!! AND USED DBreeze.Utils ByteProcessing extensions: DateTime !!!!!!!!!!!!!!!!!!!!!!!!.To_8_bytes_array_BigEndian(); &nbsp;and</SPAN></P>
<P class=c0><SPAN class=c7>!!!!!!!!!!!!!!!!!!!!!!!! &nbsp;byte[] To_DateTime_BigEndian(); &nbsp; </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>After attaching new DBreeze and recompilation of the project you will see errors, because such functions don’t exist any more in DBreeze. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Why? </SPAN></P>
<P class=c0><SPAN>It’s an issue, historical issue. Our DBreeze generic type converter (we use it in tran.Insert&lt;DateTime,DateTime .. tran.InsertPart&lt;DateTime etc.) was written before some ByteProcessingUtils functions and somehow DateTime was converted first to </SPAN><SPAN class=c7>ulong </SPAN><SPAN>and then to byte[]. Otherwise, To_DateTime_BigEndian() and To_8_bytes_array_BigEndian() from DBreeze.Utils used </SPAN><SPAN class=c7>long</SPAN><SPAN>, such unpleasant thing. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Well, now what?</SPAN></P>
<P class=c0><SPAN>So, we have decided to leave DateTime converter to work with ulong. It doesn’t have influence on the speed, and we don’t need to recreate many existing databases.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have created instead such functions in DBreeze.Utils.ByteProcessing: </SPAN><SPAN class=c7>public static DateTime To_DateTime(this byte[] value)</SPAN><SPAN>&nbsp;and this will work with </SPAN><SPAN class=c7>ulong </SPAN><SPAN>and </SPAN><SPAN class=c7>public static byte[] To_8_bytes_array(this DateTime value)</SPAN><SPAN>&nbsp;which recreates DateTime from 8-byte array. </SPAN><SPAN class=c7>With this functions we recommend to work in the future</SPAN><SPAN>. The same algorithms are used by generic converter.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But, if you have already used manual DateTime conversions, we have left two functions for compatibility: </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>public static byte[] </SPAN><SPAN class=c7>To_8_bytes_array_zCompatibility</SPAN><SPAN>(this DateTime value)</SPAN></P>
<P class=c0><SPAN>&nbsp;(this you must put in the code instead of old To_8_bytes_array_BigEndian concerning DateTime) and </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DateTime </SPAN><SPAN class=c7>To_DateTime_zCompatibility</SPAN><SPAN>(this byte[] value) (this you can use instead of old To_DateTime_BigEndian)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>They both go on to work with DateTime as long to byte[].</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, think about that and do what you should do :)</SPAN></P>
<P class=c0><SPAN>Actually, nothing should stop us on the light way of the God’s Love!</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Storing in the value columns of the fixed size.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For the last some months we have created many tables with different value configurations, combining ways of the data storage. One of the most popular way is handling value byte[] as set of columns of fixed length. We found out that we have lack of null-able data types and for this we have added in DBreeze.Utils.ByteProcessing a range of extensions for all standard null-able data types:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>You take any standard null-able data type int?, bool?, DateTime?, decimal?, float? uint? etc. and convert it into byte[] using DBreeze.Utils extensions:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp;public static byte[] To_5_bytes_array_BigEndian(this int? value)</SPAN></P>
<P class=c0><SPAN>or</SPAN></P>
<P class=c0><SPAN>public static byte[] To_16_bytes_array_BigEndian(this decimal? input)</SPAN></P>
<P class=c0><SPAN>etc...</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and the same backward:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>public static DateTime? To_DateTime_NULL(this byte[] value)</SPAN></P>
<P class=c0><SPAN>or</SPAN></P>
<P class=c0><SPAN>public static ushort? To_UInt16_BigEndian_NULL(this byte[] value)</SPAN></P>
<P class=c0><SPAN>…</SPAN></P>
<P class=c0><SPAN>etc. with NULL in the end</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c6>Note, that practically all null-able converters create byte[] on 1 byte longer then not null-able. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Sometimes in one value we hold some columns of fixed length then some DataBlocks, which represent pictures or so and then DataBlocks which represent big-text or json - serialized object parts. But we found out, that we miss storing of text in the way, like standard RDBMS make that: nvarchar(50) NULL or varchar(75). Sure we can use DataBlocks for that, but sometimes we don’t want it, especially having that DataBlock reference will reside 16 bytes.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have added in DBreeze.Utils ByteProcessing two more extensions:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>public static byte[] To_FixedSizeColumn(this string value, short fixedSize, bool isASCII)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>public static string From_FixedSizeColumn(this byte[] value, bool isASCII)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>They both will emulate behaviour of RDBMS text fields of the fixed reservation length. Maximum 32KB. Minimum 1 byte for ASCII text and 4 bytes for UTF-8 text. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Take a string (it can be also NULL) and say:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>string a = “my text”;</SPAN></P>
<P class=c0><SPAN>byte[] bta = a.</SPAN><SPAN class=c7>To_FixedSizeColumn(50,true);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and you will receive byte array of 50+2 =</SPAN><SPAN class=c7>&nbsp;52 bytes</SPAN><SPAN>&nbsp;this you can store in your value from specific place (let’s say 10). </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Note, returned size will be always 2 bytes longer we need them to store length of the real text inside of the fixed-size array and NULL flag.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Then take your value.Substring(10,52).</SPAN><SPAN class=c7>From_FixedSizeColumn(true) </SPAN><SPAN>and you will receive your “my text”. &nbsp;isASCII must be set to false if you store UTF-8 value. If size of the text exceeds the fixedSize parameter, then value will be truncated (correct algorithm is used, so only full UTF-8 chars will be stored without any garbage bytes in the end).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Sometimes, it’s very useful as a first byte of the value to setup a row version, then, depending upon this version, the further content of the value can have different configurations of the content.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20121012]</SPAN></P>
<P class="c1 c0"><SPAN class=c7></SPAN></P>
<P class=c0><SPAN class="c7 c13">Behaviour of the iterators with the modification instructions inside.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Let’s assume that before every following example, we delete table “t1” and then execute such insert:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = -200000; i &lt; 800000; i++)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;int, int&gt;("t1", i, i);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Sometimes it’s interesting for us to make table modifications while iteration, like here:</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//t1 is not in modification list, enumerators visibility scope is “parallel read”</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c11"><SPAN class=c5>foreach (var row in tran.SelectForward&lt;int, int&gt;("t1"))</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.RemoveKey&lt;int&gt;("t1", row.Key); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>in such example it will work good.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In the next example it will also work:</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SynchronizeTables("t1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>//t1 is in modification list, enumerators visibility scope is “synchronized read/write”</SPAN></P>
<P class=c0><SPAN class=c5>//probably we can see changes made inside of iteration procedure.</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var </SPAN><SPAN class="c7 c5">en </SPAN><SPAN class=c5>= tran.SelectForward&lt;int, int&gt;("t1").</SPAN><SPAN class="c7 c5">GetEnumerator</SPAN><SPAN class=c5>();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (</SPAN><SPAN class="c7 c5">en</SPAN><SPAN class=c5>.</SPAN><SPAN class="c7 c5">MoveNext</SPAN><SPAN class=c5>())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.RemoveKey&lt;int&gt;("t1", en.Current.Key);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Enumerator en, refers to writing root at this moment, because our table was added into modification list (by SynchronizeTable or any other modification command, like insert, remove etc...), and changes of the table, even before committing, can be reflected inside the enumerator. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But, we delete the same key which we read, that’s why this task will be accomplished good. We don’t insert or delete “elements of the future iterations”.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>In the next example we can have not desired behaviour:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SynchronizeTables("t1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>//t1 is in modification list, enumerators visibility scope is “synchronized read/write”</SPAN></P>
<P class=c0><SPAN class=c5>//probably we can see changes made inside of iteration procedure.</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class="c7 c5">int pq = 799999;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var en = tran.SelectForward&lt;int, int&gt;("t1").GetEnumerator();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (en.MoveNext())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.RemoveKey&lt;int&gt;("t1", </SPAN><SPAN class="c7 c5">pq</SPAN><SPAN class=c5>);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">pq--;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>We will not delete all keys in the previous example. Enumerator will stop to iterate somewhere in the middle, where exactly - depends upon key structure and not really useful for us.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, if you are going to iterate something and change possible “elements of the future iterations”, there is no guarantee for the correct logic execution. This concerns synchronized iterators.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To make it correct, we have added for every range select function an overload with the parameter </SPAN><SPAN class=c7>bool AsReadVisibilityScope</SPAN><SPAN>. It concerns nested tables range select functions also.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now we can make something like this:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SynchronizeTables("t1");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>//t1 is in modification list, enumerators visibility scope is “synchronized read/write”</SPAN></P>
<P class=c0><SPAN class=c5>//probably we can see changes made inside of iteration procedure.</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class="c7 c5">int pq = 799999;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var en = tran.SelectForward&lt;int, int&gt;("t1"</SPAN><SPAN class=c4>, true</SPAN><SPAN class=c5>).GetEnumerator();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (en.MoveNext())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.RemoveKey&lt;int&gt;("t1", </SPAN><SPAN class="c7 c5">pq</SPAN><SPAN class=c5>);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">pq--;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c0 c11"><SPAN class=c5>tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>All keys will be deleted correctly. Because our enumerator’s visibility scope will be the same as in parallel thread, so it will see only committed data projection, before the start of the current transaction.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now we can vary which visibility scope for the enumerator, whose table is inside of modification list, we want to choose, synchronized or parallel. Default range selects, without extra parameter, if table is in modification list will return synchronized view.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20121015]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Secondary Indexes. Going deeper.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Transaction/NestedTable method </SPAN><SPAN class=c7>Select </SPAN><SPAN>now is also overloaded with </SPAN><SPAN class=c7>bool AsReadVisibilityScope, </SPAN><SPAN>for the same purposes as described in the previous chapter. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Let’s assume that we have an object:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>public class Article</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[PrimaryKey]</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public long Id = 12;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public string Name = “A1”;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[SecondaryKey]</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public float Price = 15f;</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>Primary and Secondary keys attributes, for now, don’t exist in DBreeze. But idea is following: from field “Id” we want to make Primary index/key and from field “Price” we want to create one of our secondary indexes.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For now DBreeze doesn’t have extra object layer, so we would make such save in the following format:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze;</SPAN></P>
<P class=c0><SPAN class=c5>using DBreeze.Utils;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>public void SaveObject(Article a)</SPAN></P>
<P class=c0><SPAN class=c5>{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] ptr=null;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c7 c5">//Inserting into Primary Table</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;long,byte[]&gt;</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>(“Article”,</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>a.Id.To_8_bytes_array_BigEndian(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//Id - primary key</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>a.Name.To_FixedSizeColumn(50, false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//let it be not DataBlock</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>.Concat(</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>a.Price.To_4_bytes_array_BigEndian()</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>),</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>out ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//getting back a physical pointer</SPAN></P>
<P class="c0 c12"><SPAN class=c5>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class="c1 c0 c12"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class="c7 c5">//Inserting into Secondary Index table</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;byte[],byte[]&gt;</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>(“ArticleIndexPrice”,</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>a.Price.To_4_bytes_array_BigEndian() &nbsp; &nbsp;</SPAN><SPAN class="c7 c5">//compound key: price+Id</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>.Concat(</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.Id.To_8_bytes_array_BigEndian()</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>,</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//value is a pointer to the primary table</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>);</SPAN></P>
<P class="c0 c12"><SPAN class=c5>)</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c0 c11"><SPAN class=c5>}</SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Something like this. In the real life all primary and secondary indexes could be packed into the nested tables of one MasterTable under different keys.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have filled 2 tables. First is “Article”. As key there we store Article.Id as value we store article name and price. Second table is “</SPAN><SPAN>ArticleIndexPrice”. Its key is constructed from (float)Price+(long)ArticleId - it’s unique, sortable, comparable and searchable. Such technique was described in previous articles. As a value we store physical pointer to the primary key inside of the “Article” table. When we have such physical pointer, searching of Key/Value of the PrimaryTable “Article” is only one HDD hit.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But keys and values are not always static. Sometimes we remove articles, sometimes we change the price or even expand the value (in the last case, we need to save new physical pointer into secondary index table).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we remove Article, we must remove compound key from the table “ArticleIndexPrice” also.</SPAN></P>
<P class=c0><SPAN>When we update price, inside of table Article, we must delete old compound key from the table “ArticleIndexPrice” and create new one.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>It means, that every time when we insert something into table Article - it can be counted as a probable update, and we must check, if row with such Id exists before insert. If yes then we must read it, delete compound key, construct and insert new compound key into the table “ArticleIndexPrice” and finally update value in the table “Article”.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This all can slow down insert process very much.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>That’s why we have added for every modification command, inside of the transaction class and nested table class, &nbsp;useful overloads:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Modification commands overloads (the same for nested tables):</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>public void </SPAN><SPAN class=c7>Insert</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey key, TValue value, out byte[] refToInsertedValue, </SPAN><SPAN class=c4>out bool WasUpdated</SPAN><SPAN>)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>public void </SPAN><SPAN class=c7>InsertPart</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey key, TValue value, uint startIndex, out byte[] refToInsertedValue, </SPAN><SPAN class=c4>out bool WasUpdated</SPAN><SPAN>)</SPAN></P>
<P class=c0><SPAN>public void </SPAN><SPAN class=c7>ChangeKey</SPAN><SPAN>&lt;TKey&gt;(string tableName, TKey oldKey, TKey newKey, out byte[] ptrToNewKey, </SPAN><SPAN class=c4>out bool WasChanged</SPAN><SPAN>)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>public void </SPAN><SPAN class=c7>RemoveKey</SPAN><SPAN>&lt;TKey&gt;(string tableName, TKey key, </SPAN><SPAN class=c4>out bool WasRemoved</SPAN><SPAN>)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Actually, Dbreeze, when inserts data, knows, if it’s going to be an update or new insert. That’s why Dbreeze can notify us about this.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We go on to insert data in usual manner. If flag </SPAN><SPAN class=c4>WasUpdated </SPAN><SPAN>equals to true, then we know that it was an update. We can use our new, </SPAN><SPAN class=c7>overloaded </SPAN><SPAN>with visibility scope parameter, </SPAN><SPAN class=c7>Select </SPAN><SPAN>to get key/value pair, which was before modification and change secondary index table. We need to make this action only in case of update/remove/change command, but not in case of the new insert.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20121016]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Secondary Indexes. Going deeper. Part 2</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we store inside of value DataBlocks (not just serialized value or columns of fixed length), before we make an update of such value, we must read it in any case previous value content (to get DataBlocks initial pointers for updates). So, again every insert can be counted as probable update. Following technique/benchmark shows us time consumption for reading previous row value version before insert:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This is a standard insert:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] ptr=null;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool wasUpdated = false;</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.StartCounter("a");</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = -200000; i &lt; 800000; i++)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", i, i, out ptr, out wasUpdated); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>DBreeze.Diagnostic.SpeedStatistic.PrintOut("a", true);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Operation took </SPAN><SPAN class=c7>9300 ms (9 sec)</SPAN><SPAN>. </SPAN><SPAN class=c7>1 MLN</SPAN><SPAN>&nbsp;of </SPAN><SPAN class=c7>inserts</SPAN><SPAN>.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This is an insert with getting previous row version before insert:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte[] ptr=null; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN></P>
<P class="c0 c11"><SPAN class=c5>DBreeze.DataTypes.Row&lt;int, int&gt; row = null;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DBreeze.Diagnostic.SpeedStatistic.StartCounter("a");</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = -200000; i &lt; 800000; i++)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class="c7 c5">//Note, we use Select with VisibilityScope=Parallel Read</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c5"></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row = tran.Select&lt;int, int&gt;("t1", i,</SPAN><SPAN class=c4>true</SPAN><SPAN class=c5>); &nbsp; &nbsp;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c3 c0 c11"><SPAN class=c5>if (row.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//do update</SPAN></P>
<P class="c0 c12 c11"><SPAN class=c5>tran.Insert&lt;int, int&gt;("t1", i, i, out ptr);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class="c7 c5">//do insert</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", i, i, out ptr);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreeze.Diagnostic.SpeedStatistic.PrintOut("a", true);</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Commit();</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This operation took </SPAN><SPAN class=c7>10600 ms (10 sec)</SPAN><SPAN>. </SPAN><SPAN class=c7>1 MLN</SPAN><SPAN>&nbsp;of </SPAN><SPAN class=c7>inserts, </SPAN><SPAN>distinguishing between updates and inserts. </SPAN></P>
<P class=c0><SPAN class=c7>Remember, that DBreeze insert and select algorithms work with maximum efficiency in bulk operations, when keys are supplied sorted in ascending order (descending is a bit slower). So, sort bulk chunks in memory before inserts/selects.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Previous 2 examples were about pure inserts, and we run them again having data already in the table, so all records have to be updated:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>1 example - 1 MLN of updates took 28 sec</SPAN></P>
<P class=c0><SPAN>2 example - 1 MLN of updates with (getting row previous version) took 36 sec.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20121023]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Dbreeze like in-memory database.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Dbreeze can reside also fully in-memory. It’s just a feature. Having the same functionality as disk-based version. </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Instantiating example:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>DBreeze.DBreezeEngine memeng = new DBreezeEngine(new DBreezeConfiguration()</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Storage = &nbsp;DBreezeConfiguration.eStorage.MEMORY</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>using (var tran = memeng.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;{</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 1000000; i++)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, int&gt;("t1", i, i);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(tran.Count("t1"));</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>}</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN>It works a bit slower then .NET Dictionary or SortedDictionary, because has lots of sub-systems inside, which must be supported, and designed to work with very large data sets, without index fragmentation after continuous inserts, updates and deletes.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">“Out-of-the-box” bulk insert speed increase.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We have increased standard bulk insert speed of DBreeze (about 5 times), by adding a special memory cache layer before flushing data on the disk. By standard configuration, 20 tables, which are written in parallel, receive such memory buffer of size 1MB each, before disk flush. The 21-th (and so on, parallel) will write without buffer. After disposing of the writing transactions other tables can receive such buffer, so it’s not bound to the tables names - tables are chosen automatically right in time of the insert.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now DBreeze, in standard configuration, can store in bulk (ascending ordered) 500K records per 1 seconds (Benchmark PC is taken). 6 parallel threads could write into 6 different tables 1MLN of records each, for the 3.4 seconds, what was about 40MB/s and 1.7 MLN simple records per second (see Benchmarking document).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20121101]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Iterations SelectBackwardStartsWithClosestToPrefix and SelectForwardStartsWithClosestToPrefix.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>They both concern master and nested tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If we have in the table string keys:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>"check”</SPAN></P>
<P class=c0><SPAN>"sam"</SPAN></P>
<P class=c0><SPAN>"slash”</SPAN></P>
<P class=c0><SPAN>"slam"</SPAN></P>
<P class=c0><SPAN>"what"</SPAN></P>
<P class=c0><SPAN class="c5 c10">string prefix = "slap";</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">foreach (var row in tran.SelectForwardStartsWithClosestToPrefix&lt;string, byte&gt;("t1", prefix))</SPAN></P>
<P class=c0><SPAN class="c5 c10">{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(row.Key);</SPAN></P>
<P class=c0><SPAN class="c5 c10">}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Result:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>slam</SPAN></P>
<P class=c0><SPAN>slash</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>and for </SPAN></P>
<P class=c0><SPAN class="c5 c10">foreach (var row in tran.SelectBackwardStartsWithClosestToPrefix&lt;string, byte&gt;("t1", prefix))</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Result:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>slash</SPAN></P>
<P class=c0><SPAN>slam</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20121111]</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Alternative tables storage locations.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Starting from current DBreeze version we are able to set up tables locations by table names patterns globally. We can mix tables physical locations inside of one DBreeze instance. Tables can reside in different folders, on different hard drives and even in memory.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreezeConfiguration object is enriched with the public accessible Dictionary AlternativeTablesLocations.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now we can create DBreeze configuration in the following format:</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">DBreezeConfiguration conf = new DBreezeConfiguration()</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBreezeDataFolderName = @"D:\temp\DBreezeTest\DBR1",</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Storage = DBreezeConfiguration.eStorage.DISK,</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c7 c5 c10">//SETTING UP ALTERNATIVE FOLDER FOR TABLE t11</SPAN></P>
<P class=c0><SPAN class="c5 c10">conf.AlternativeTablesLocations.Add(</SPAN><SPAN class="c10 c25">"t11</SPAN><SPAN class="c5 c10">",@"D:\temp\DBreezeTest\DBR1\INT");</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c7 c5 c10">//SETTING UP THAT ALL TABLES STARTING FROM “mem_” must reside in-memory</SPAN></P>
<P class=c0><SPAN class="c5 c10">conf.AlternativeTablesLocations.Add("</SPAN><SPAN class="c25 c10">mem_*</SPAN><SPAN class="c5 c10">", </SPAN><SPAN class="c7 c5 c10">String.Empty</SPAN><SPAN class="c5 c10">);</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c7 c5 c10">//SETTING UP Table pattern to reside in different folder</SPAN></P>
<P class=c0><SPAN class="c5 c10">conf.AlternativeTablesLocations.Add(“</SPAN><SPAN class="c25 c10">t#/Items</SPAN><SPAN class="c5 c10">", @"D:\temp\DBreezeTest\DBR1\EXTRA");</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp;engine = new DBreezeEngine(conf);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>So, if </SPAN><SPAN class=c7>value </SPAN><SPAN>of the Dictionary AlternativeTablesLocations key is </SPAN><SPAN class=c7>empty</SPAN><SPAN>, table will be automatically forced to work </SPAN><SPAN class=c7>in-memory</SPAN><SPAN>. If pattern for the table is not found, table will be created, overriding DBreeze main configuration settings (DBreezeDataFolderName and StorageType).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If </SPAN><SPAN class=c7>one table</SPAN><SPAN>&nbsp;corresponds </SPAN><SPAN class=c7>to some patterns</SPAN><SPAN>, the </SPAN><SPAN class=c7>first</SPAN><SPAN>&nbsp;one will be </SPAN><SPAN class=c7>taken</SPAN><SPAN>.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Patterns logic is the same as in “Transaction Synchronize Tables”:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>$ * # - pattern extra symbols</SPAN></P>
<P class=c0><SPAN>"U" - intersects, “!U” - doesn’t intersect</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures etc...</SPAN></P>
<P class=c0><SPAN># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</SPAN></P>
<P class=c0><SPAN>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123; &nbsp;Items$ !U Items123/Pictures</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Patterns can be combined:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Items#/Pictures#/Thumbs*</SPAN><SPAN>&nbsp;can intersect </SPAN><SPAN class="c6 c5">Items1/Pictures125/Thumbs44</SPAN><SPAN>&nbsp;or &nbsp;</SPAN><SPAN class="c6 c5">Items458/Pictures4658/Thumbs1000</SPAN><SPAN>&nbsp;etc...</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Incremental backup restorer works on the file level and knows nothing about user’s logical table names. It will restore all tables in one specified folder. Later, after starting DBreeze and reading the scheme, it’s possible manually to reside disk table files into corresponded physical places due to the storage logic.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20130529] </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Speeding up batch modifications (updates, random inserts)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To economize disk space DBreeze tries to utilize the same HDD space, if it’s possible, in case of different types of updates.</SPAN></P>
<P class=c0><SPAN>There are 3 places where updates are possible:</SPAN></P>
<P class=c0><SPAN>- Update of search trie nodes (LianaTrie nodes)</SPAN></P>
<P class=c0><SPAN>- Update of Key/Values </SPAN></P>
<P class=c0><SPAN>- Update of DataBlocks</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>To be sure that overwriting data file will not be corrupted in case of power loss, first we have to write data into rollback file, then into data file. DBreeze in standard mode excludes any OS intermediate cache (only internal DBreeze cache) and makes writes to the “bare metal”. Today’s HDDs and even SSDs are quite slow for the random write. That’s why we use a technique of changing random writes into sequential writes.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>When we use DBreeze, for standard data accumulation of the random data from different sources, inside of small transactions, the speed degrade is not so visible. But we can see it very good when we need to update a batch of specific data.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>We DON’T SEE SPEED DEGRADE, when</SPAN><SPAN>&nbsp;we insert batch of growing up keys - any newly inserted key is always bigger than maximal existing key (SelectForward will return newly inserted key as the last one). For such case we should do nothing.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>We CAN SEE SPEED DEGRADE, when </SPAN><SPAN>we update batch of values or data-blocks or if we insert a batch of keys in random order and, especially, if these keys have high entropy.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For such cases we have integrated new methods for transactions and for nested tables:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>tran.</SPAN><SPAN class=c7>Technical_SetTable_OverwriteIsNotAllowed(”t1”);</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>or</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>var tblABC = tran.InsertTable&lt;byte[]&gt;(“masterTable”, new byte[] { 1 }, 0);</SPAN></P>
<P class=c0><SPAN>tblABC .</SPAN><SPAN class=c7>Technical_SetTable_OverwriteIsNotAllowed();</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c6">- This technique is interesting for the transactions with specific batch modifications, where speed really matters. Only developer can answer this question and find a balance.</SPAN></P>
<P class=c0><SPAN class="c7 c6">- This technique is not interesting for the memory based data stores.</SPAN></P>
<P class=c0><SPAN class="c7 c6">- These methods work only inside of one transaction and must be called for every table or nested table separately, before table modification command.</SPAN></P>
<P class=c0><SPAN class="c7 c6">- When new transaction starts, overwrite automatically will be allowed again for all tables and nested tables.</SPAN></P>
<P class=c0><SPAN class="c7 c6">- Overwriting concerns all: search trie nodes, values and data blocks.</SPAN></P>
<P class=c0><SPAN class="c7 c6">- Remember always to sort batch ascending by key, before insert - it will economize HDD space.</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c6"></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c6>Of course this technique makes data file bigger, but it returns the desired speed. All data which could be overwritten will be written to the end of the file.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c4 c6">Note</SPAN></P>
<P class="c1 c0"><SPAN class="c4 c6"></SPAN></P>
<P class=c0><SPAN>When </SPAN><SPAN class=c7>Technical_SetTable_OverwriteIsNotAllowed</SPAN><SPAN>&nbsp;is used, </SPAN><SPAN class=c7>InsertPart </SPAN><SPAN>still tries to update values, that can bring to speed loss. If we need the speed while update, we can use such </SPAN><SPAN class=c7>workaround</SPAN><SPAN>:</SPAN></P>
<UL class="c18 lst-kix_ur61xqeyv3sy-0 start">
<LI class="c3 c0 c9"><SPAN>don't use InsertPart, only Insert</SPAN></LI>
<LI class="c3 c0 c9"><SPAN>read the whole value into memory as byte[]</SPAN></LI>
<LI class="c3 c0 c9"><SPAN>then change its middle part (with DBreeze.Utils.BytesProcessing CopyInside or CopyInsideArrayCanGrow)</SPAN></LI>
<LI class="c3 c0 c9"><SPAN>insert the complete value.</SPAN></LI>
<LI class="c3 c0 c9"><SPAN>All the time </SPAN><SPAN class=c7>Technical_SetTable_OverwriteIsNotAllowed</SPAN><SPAN>&nbsp;can be on.</SPAN></LI></UL>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Source code received new folder DBreeze\bin\Release\NET40 where we store DBreeze.dll ready for MONO and .NET4&gt; usage. This folder DBreeze\bin\Release\ will hold DBreeze for .NET35 (Windows only). </SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN class="c17 c7">DBreeze version for .NET35 can be used only under Windows, cause utilizes system API FlushFileBuffers from kernel32.dll</SPAN></P>
<P class="c1 c0"><SPAN class=c17></SPAN></P>
<P class=c0><SPAN class="c17 c7">DBreeze version for .NET40 doesn’t use any system API functions and can be used under Linux MONO and under .NET 4&gt;. For Windows, be sure to have latests .NET Framework starting from 4.5, because there Microsoft has fixed bug with FileStream.Flush(true).</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20130608] </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Restoring table from the other table.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Starting from DBreeze version 01.052 we can restore table from the other source table on the fly.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>The example code of compaction:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">private void TestCompact()<BR>&nbsp; &nbsp; &nbsp; &nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10"><BR><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;using (var tran = engine.GetTransaction())<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;int, int&gt;("t1", 1, 1);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tran.Commit();<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <BR><BR>&nbsp; &nbsp; </SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBreezeEngine engine2=new DBreezeEngine(@”D:\temp\DBreezeTest\DBR2”)<BR><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;using (var tran = engine.GetTransaction())<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tran.SynchronizeTables("t1");</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using (var tran2 = engine2.GetTransaction())<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Copying from main engine (Table t1) to engine2 (table “t1”), with changing all values to 2</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foreach (var row in tran.SelectForward&lt;int,int&gt;("t1"))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran2.Insert&lt;int,int&gt;(“t1”,row.Key,2);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran2.Commit();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; engine2.Dispose();</SPAN></P>
<P class=c0><SPAN class="c5 c10">//engine2 is fully closed.</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //moving table from engine2 (physical name) to main engine (logical name)</SPAN></P>
<P class=c0><SPAN class="c5 c10"><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN><SPAN class=c10>&nbsp;</SPAN><SPAN class="c7 c10">&nbsp;tran.RestoreTableFromTheOtherFile("t1", @"D:\temp\DBreezeTest\DBR2\10000000"); </SPAN><SPAN class=c10>&nbsp; &nbsp; &nbsp; </SPAN></P>
<P class=c0><SPAN class=c10>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Point555 </SPAN><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<BR><BR>//Checking<BR><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;using (var tran = engine.GetTransaction())<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foreach (var row in tran.SelectBackward&lt;int,int&gt;("t1"))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<BR>//GETTING KEY 2<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine("Key: {0}", row.Key);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</SPAN></P>
<P class=c0><SPAN class="c5 c10"><BR>&nbsp; &nbsp; &nbsp; &nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Up to point555 everything was ok, while copying data from one engine into another, parallel threads could read data from table “t1” of the main engine, parallel writing threads of course were blocked by </SPAN><SPAN class="c5 c10">&nbsp;tran.SynchronizeTables("t1"); </SPAN><SPAN>command.</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN>Startign from point555 some parallel threads which were reading table “t1” could have in memory reference to the old physical file, reading values from such references can bring to DBreeze TABLE_WAS_CHANGED_LINKS_ARE_NOT_ACTUAL exception.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Discussion link is </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=https://www.google.com/url?q%3Dhttps%253A%252F%252Fdbreeze.codeplex.com%252Fdiscussions%252F446373%26sa%3DD%26sntz%3D1%26usg%3DAFQjCNGah6q7r47HEU9V1NeNvfTojwSTww&amp;sa=D&amp;usg=AFQjCNFNL41teFwJXPCiKo5hXh-OCWUmjw">https://dbreeze.codeplex.com/discussions/446373</A></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note: DON’T USE COMMIT AFTER </SPAN><SPAN class="c7 c10">RestoreTableFromTheOtherFile COMMAND, just close transaction.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20130613] </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Full tables locking inside of transaction.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Parallel threads can open transactions and in parallel read the same tables, in our standard configuration. For writing threads we use tran.SynchronizeTables command to sequentialize writing threads access to the tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>But what if we want to block access to the tables even in parallel reading threads, while modification commands of our current transaction are not yet finished? </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For this we have developed special type of transaction.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c5 c10">using (var tran = engine.GetTransaction(eTransactionTablesLockTypes.EXCLUSIVE, "t1", "p*", "c$"))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;int, string&gt;("t1", 1, "Kesha is a good parrot");</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">using (var tran = engine.GetTransaction(eTransactionTablesLockTypes.SHARED, "t1"))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;int, string&gt;("t1", 1, "Kesha is VERY a good parrot");</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Inside of such transaction we want to define the lock type for the listed tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>Note, we must use either first transaction type (engine.GetTransaction()) or new type (with SHARED/EXCLUSIVE) for the same tables among the whole program.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Example of usage:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>&nbsp; &nbsp; </SPAN><SPAN class="c5 c10">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void ExecF_003_1()</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction(eTransactionTablesLockTypes.EXCLUSIVE, "t1", "p*", "c$"))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("T1 {0}&gt; {1}; {2}", DateTime.Now.Ticks, System.Threading.Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString("HH:mm:ss.ms"));</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, string&gt;("t1", 1, "Kesha is a good parrot");</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(2000);</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void ExecF_003_2()</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;string&gt; tbls = new List&lt;string&gt;();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbls.Add("t1");</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbls.Add("v2");</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction(eTransactionTablesLockTypes.SHARED, tbls.ToArray()))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("T2 {0}&gt; {1}; {2}", DateTime.Now.Ticks, System.Threading.Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString("HH:mm:ss.ms"));</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var r in tran.SelectForward&lt;int, string&gt;("t1"))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(r.Value);</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void ExecF_003_3()</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using (var tran = engine.GetTransaction(eTransactionTablesLockTypes.SHARED, "t1"))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("T3 {0}&gt; {1}; {2}", DateTime.Now.Ticks, System.Threading.Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString("HH:mm:ss.ms"));</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This must be used in any case, when Shared threads can have parallel writes</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.SynchronizeTables("t1");</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Insert&lt;int, string&gt;("t1", 1, "Kesha is a VERY good parrot");</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tran.Commit();</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var r in tran.SelectForward&lt;int, string&gt;("t1"))</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(r.Value);</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">using DBreeze.Utils.Async;</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void testF_003()</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action t2 = () =&gt;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecF_003_2();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2.DoAsync();</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action t1 = () =&gt;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecF_003_1();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1.DoAsync();</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action t3 = () =&gt;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecF_003_3();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t3.DoAsync();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Transactions marked as SHARED will be executed in parallel. EXCLUSIVE transaction will wait till other transactions, consuming the same tables, are stopped and then block access for other threads (reading or writing) to the consuming tables.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This approach is good for avoiding transaction exceptions, in case of data compaction or removing keys with file re-creation, described in previous chapter.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20130811] </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Remove KeyValue and get deleted value and notification if value existed in one round.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For this we have added overload in Master and in Nested tables: </SPAN><SPAN class=c7>RemoveKey</SPAN><SPAN>&lt;TKey&gt;(string tableName, TKey key, out bool WasRemoved, out byte[] deletedValue)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20130812] </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Insert key overload for Master and Nested table, letting not to overwrite key if it already exists.</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class=c0><SPAN>For this we have added overload in Master and in Nested tables:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>public void </SPAN><SPAN class=c7>Insert</SPAN><SPAN>&lt;TKey, TValue&gt;(string tableName, TKey key, TValue value, out byte[] refToInsertedValue, out bool </SPAN><SPAN class=c7>WasUpdated</SPAN><SPAN>, bool </SPAN><SPAN class=c7>dontUpdateIfExists</SPAN><SPAN>)</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>WasUpdated will become true, if value exists, and false if such value is not in DB.</SPAN></P>
<P class=c0><SPAN class=c7>dontUpdateIfExists, </SPAN><SPAN>equal to true, will not give DB to make an update.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Speeding up select operations and traversals with ValuesLazyLoadingIsOn.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>DBreeze uses lazy value loading technique. For example, we can say </SPAN></P>
<P class=c0><SPAN>var row = transaction.Select&lt;int,int&gt;(“t1”,1);</SPAN></P>
<P class=c0><SPAN>at this moment we receive a row. We know that such row exists by row.Exists property and we know its key by row.Key property. At this moment value is still not taken into memory from disk. It will be read out from DB only when we instruct row.Value.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Sometimes it is good, when for us the only key is enough. Such cases can happen when we store secondary index and the link, to the primary table, as a part of the key. Or if we have “multiple columns” in one row. We need to get only one column and don’t need to get complete, probably huge, value.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Nevertheless, lazy load will work a bit slower, in compare with getting key and value in one round, due to extra HDD hits.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>For this case we have developed in transaction a property/switch &nbsp;tran.</SPAN><SPAN class=c7>ValuesLazyLoadingIsOn</SPAN><SPAN>. By default it is ON (true), just set it to false and all transaction &nbsp;traversal commands, like SelectForwards, Backwards etc., will return us row already with a read out Value. This switch will also influent NestedTables which we get from tran.InsertTable, SelectTable and row.GetTable. </SPAN></P>
<P class=c0><SPAN>We can set this switch many times within one transaction to tune the speed of different queries.</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c7>[20140603] </SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c7 c13">Storing byte[] serialized objects as value, native support.</SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN class="c7 c13"></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Starting from now we can bind any byte[] serializer/deserializer to DBreeze in following manner:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>This declaration must be done right after DBreeze instantiation, before its real usage.</SPAN></P>
<P class="c1 c0"><SPAN class=c10></SPAN></P>
<P class=c0><SPAN class="c5 c10">DBreeze.Utils.CustomSerializator.ByteArraySerializator = SerializeProtobuf;</SPAN></P>
<P class=c0><SPAN class="c5 c10">DBreeze.Utils.CustomSerializator.ByteArrayDeSerializator = DeserializeProtobuf;</SPAN></P>
<P class="c1 c0"><SPAN class=c10></SPAN></P>
<P class=c0><SPAN class=c10>where...</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>We use mostly Protobuf.NET serializer in our projects. So example will be done also with Protobuf. Get it via Nuget or make reference to it (protobuf-net.dll) .</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Here are custom wrapping functions for Protobuf:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp;public static T DeserializeProtobuf&lt;T&gt;(this byte[] data)</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T ret = default(T);</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using (System.IO.MemoryStream ms = new System.IO.MemoryStream(data))</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ProtoBuf.Serializer.Deserialize&lt;T&gt;(ms);</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ms.Close();</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ret;</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; public static object DeserializeProtobuf(byte[] data, Type T)</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object ret = null;</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using (System.IO.MemoryStream ms = new System.IO.MemoryStream(data))</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ProtoBuf.Serializer.NonGeneric.Deserialize(T, ms);</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ms.Close();</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ret;</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; public static byte[] SerializeProtobuf(this object data)</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte[] bt = null;</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using (System.IO.MemoryStream ms = new System.IO.MemoryStream())</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProtoBuf.Serializer.NonGeneric.Serialize(ms, data);</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bt = ms.ToArray();</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ms.Close();</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c8"></SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return bt;</SPAN></P>
<P class=c0><SPAN class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>Now lets prepare an object for storing in DBreeze, decorated with Protobuf attributes (extra documentation about protobuf can be found on its website):</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp;[ProtoBuf.ProtoContract]</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public class XYZ</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public XYZ()</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P1 = 12;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P2 = "sdfs";</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; </SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[ProtoBuf.ProtoMember(1, IsRequired = true)]</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public int P1 { get; set; }</SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class="c1 c0"><SPAN class="c5 c10"></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[ProtoBuf.ProtoMember(2, IsRequired = true)]</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public string P2 { get; set; }</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And now lets use DBreeze for storing object:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Insert&lt;int, XYZ&gt;("t1", 1, new XYZ() { &nbsp;P1 = 44, P2 = "well"});</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tran.Commit();</SPAN></P>
<P class=c0><SPAN class="c5 c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>And for retrieving object:</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN class=c5>XYZ obj = null;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class=c5>&nbsp;using (var tran = engine.GetTransaction())</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var row = tran.Select&lt;int, XYZ&gt;("t1", 1);</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (row.Exists)</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj = row.Value;</SPAN></P>
<P class="c1 c0"><SPAN class=c5></SPAN></P>
<P class=c0><SPAN class="c7 c5">//!!! NOTE better to assign row.Value to “obj” and then use “obj” among the program. &nbsp;//Calling row.Value causes to rereading data from the table in case of default //ValueLazyLoadingIsOn</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class=c0><SPAN class=c5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class=c0><SPAN>If something is not working like it is expected, please, don’t hesitate to write down an issue comment on </SPAN><SPAN class=c16><A class=c14 href="https://www.google.com/url?q=http://dbreeze.tiesky.com&amp;sa=D&amp;usg=AFQjCNETavWyvr9IXC-AWghR4__Pw5qJhg">http://dbreeze.tiesky.com</A></SPAN></P>
<P class="c1 c0"><SPAN></SPAN></P>
<P class="c2 c0"><SPAN class=c7>Copyright © &nbsp;2012 dbreeze.tiesky.com / Alexey Solovyov / Ivars Sudmalis</SPAN></P></DIV>
<DIV id=footer><SPAN><A title="Learn more about Google Drive" href="//docs.google.com/" target=_blank>Google Диск</A></SPAN><SPAN class=dash>–</SPAN><A href="//docs.google.com/abuse?id=1IFkXoX3Tc2zHNAQN9EmGSXZGbQabMrWmpmVxFsLxLsw">Сообщение о нарушении</A><SPAN class=dash>–</SPAN><SPAN>Интервал автоматического обновления в минутах: 5</SPAN></DIV>
<SCRIPT type=text/javascript>(function(){if(window.jstiming){window.jstiming.a={};window.jstiming.b=1;var f=function(b,a,d){var c=b.t[a],e=b.t.start;if(c&&(e||d))return c=b.t[a][0],void 0!=d?e=d:e=e[0],Math.round(c-e)},m=function(b,a,d){var c="";window.jstiming.srt&&(c+="&srt="+window.jstiming.srt,delete window.jstiming.srt);window.jstiming.pt&&(c+="&tbsrt="+window.jstiming.pt,delete window.jstiming.pt);try{window.external&&window.external.tran?c+="&tran="+window.external.tran:window.gtbExternal&&window.gtbExternal.tran?c+="&tran="+window.gtbExternal.tran():
window.chrome&&window.chrome.csi&&(c+="&tran="+window.chrome.csi().tran)}catch(t){}var e=window.chrome;if(e&&(e=e.loadTimes)){e().wasFetchedViaSpdy&&(c+="&p=s");if(e().wasNpnNegotiated){var c=c+"&npn=1",g=e().npnNegotiatedProtocol;g&&(c+="&npnv="+(encodeURIComponent||escape)(g))}e().wasAlternateProtocolAvailable&&(c+="&apa=1")}var k=b.t,r=k.start,e=[],g=[],h;for(h in k)if("start"!=h&&0!=h.indexOf("_")){var l=k[h][1];l?k[l]&&g.push(h+"."+f(b,h,k[l][0])):r&&e.push(h+"."+f(b,h))}delete k.start;if(a)for(var n in a)c+=
"&"+n+"="+a[n];(a=d)||(a="https:"==document.location.protocol?"https://csi.gstatic.com/csi":"http://csi.gstatic.com/csi");return[a,"?v=3","&s="+(window.jstiming.sn||"_s")+"&action=",b.name,g.length?"&it="+g.join(","):"",c,"&rt=",e.join(",")].join("")};window.jstiming.getReportUri=m;var p=function(b,a,d){b=m(b,a,d);if(!b)return"";a=new Image;var c=window.jstiming.b++;window.jstiming.a[c]=a;a.onload=a.onerror=function(){window.jstiming&&delete window.jstiming.a[c]};a.src=b;a=null;return b};window.jstiming.report=
function(b,a,d){if("prerender"==document.webkitVisibilityState){var c=!1,e=function(){if(!c){a?a.prerender="1":a={prerender:"1"};var g;"prerender"==document.webkitVisibilityState?g=!1:(p(b,a,d),g=!0);g&&(c=!0,document.removeEventListener("webkitvisibilitychange",e,!1))}};document.addEventListener("webkitvisibilitychange",e,!1);return""}return p(b,a,d)};window.jstiming.reportDone=function(b){if(window.jstiming.b<=(b||1))return!1;for(var a in window.jstiming.a)return!1;return!0};var q=function(b,a,
d,c){return 0<d?(c?b.tick(a,c,d):b.tick(a,"",d),!0):!1};window.jstiming.getNavTiming=function(b){if(window.performance&&window.performance.timing){var a=window.performance.timing;q(b,"_dns",a.domainLookupStart)&&q(b,"dns_",a.domainLookupEnd,"_dns");q(b,"_con",a.connectStart)&&q(b,"con_",a.connectEnd,"_con");q(b,"_req",a.requestStart)&&q(b,"req_",a.responseStart,"_req");q(b,"_rcv",a.responseStart)&&q(b,"rcv_",a.responseEnd,"_rcv");if(q(b,"_ns",a.navigationStart)){q(b,"ntsrt_",a.responseStart,"_ns");
q(b,"nsfs_",a.fetchStart,"_ns");var d=!1;try{d=window.external&&window.external.startE}catch(c){}!d&&window.chrome&&window.chrome.csi&&(d=Math.floor(window.chrome.csi().startE));d&&(q(b,"_se",d),q(b,"sens_",a.navigationStart,"_se"));q(b,"ntplt0_",a.loadEventStart,"_ns");q(b,"ntplt1_",a.loadEventEnd,"_ns")}}}};})()
</SCRIPT>

<SCRIPT type=text/javascript>KX_timer.tick('tl'); if (document.location.protocol == 'https:') {window.jstiming.report(KX_timer, undefined , 'https://gg.google.com/csi');} else {window.jstiming.report(KX_timer);}</SCRIPT>

<SCRIPT type=text/javascript>(function() { var h=this;
function l(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}function aa(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}function m(a,b){function c(){}c.prototype=b.prototype;a.m=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.u=function(a,c,f){for(var g=Array(arguments.length-2),k=2;k<arguments.length;k++)g[k-2]=arguments[k];return b.prototype[c].apply(a,g)}};function q(){this.b=this.b;this.a=this.a}q.prototype.b=!1;q.prototype.l=function(){this.b||(this.b=!0,this.g())};q.prototype.g=function(){if(this.a)for(;this.a.length;)this.a.shift()()};function ba(a){a&&"function"==typeof a.l&&a.l()};var r=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},ca=/&/g,da=/</g,ea=/>/g,fa=/"/g,ga=/'/g,ha=/\x00/g,ia=/[\x00&<>"']/;function t(a,b){return a<b?-1:a>b?1:0};var u=Array.prototype,ja=u.indexOf?function(a,b,c){return u.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if("string"==typeof a)return"string"==typeof b&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};function ka(a,b,c){for(var d in a)b.call(c,a[d],d,a)};function v(){this.a=y}var y={};function z(){this.a="";this.b=A}var A={};function B(a){var b=new z;b.a=a;return b}B("<!DOCTYPE html>");B("");var C;a:{var D=h.navigator;if(D){var E=D.userAgent;if(E){C=E;break a}}C=""}function F(a){return-1!=C.indexOf(a)};var G=F("Opera")||F("OPR"),H=F("Trident")||F("MSIE"),I=F("Edge"),la=I||H,J=F("Gecko")&&!(-1!=C.toLowerCase().indexOf("webkit")&&!F("Edge"))&&!(F("Trident")||F("MSIE"))&&!F("Edge"),K=-1!=C.toLowerCase().indexOf("webkit")&&!F("Edge"),ma=F("Macintosh");function na(){var a=C;if(J)return/rv\:([^\);]+)(\)|;)/.exec(a);if(I)return/Edge\/([\d\.]+)/.exec(a);if(H)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(K)return/WebKit\/(\S+)/.exec(a)}function L(){var a=h.document;return a?a.documentMode:void 0}
var oa=function(){if(G&&h.opera){var a;var b=h.opera.version;try{a=b()}catch(c){a=b}return a}a="";(b=na())&&(a=b?b[1]:"");return H&&(b=L(),b>parseFloat(a))?String(b):a}(),pa={};
function M(a){var b;if(!(b=pa[a])){b=0;for(var c=r(String(oa)).split("."),d=r(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",k=d[f]||"",w=RegExp("(\\d*)(\\D*)","g"),p=RegExp("(\\d*)(\\D*)","g");do{var n=w.exec(g)||["","",""],x=p.exec(k)||["","",""];if(0==n[0].length&&0==x[0].length)break;b=t(0==n[1].length?0:parseInt(n[1],10),0==x[1].length?0:parseInt(x[1],10))||t(0==n[2].length,0==x[2].length)||t(n[2],x[2])}while(0==b)}b=pa[a]=0<=b}return b}
var qa=h.document,N=qa&&H?L()||("CSS1Compat"==qa.compatMode?parseInt(oa,10):5):void 0;!J&&!H||H&&9<=N||J&&M("1.9.1");H&&M("9");function O(a){O[" "](a);return a}O[" "]=function(){};var ra=!H||9<=N,sa=!H||9<=N,ta=H&&!M("9");!K||M("528");J&&M("1.9b")||H&&M("8")||G&&M("9.5")||K&&M("528");J&&!M("8")||H&&M("9");function P(a,b){this.type=a;this.a=this.target=b;this.f=!1}P.prototype.c=function(){this.f=!0};function Q(a,b){P.call(this,a?a.type:"");this.a=this.target=null;this.g=!1;this.b=null;if(a){this.type=a.type;this.target=a.target||a.srcElement;this.a=b;var c=a.relatedTarget;if(c&&J)try{O(c.nodeName)}catch(d){}this.g=a.ctrlKey;this.b=a;a.defaultPrevented&&this.c()}}m(Q,P);var ua=[1,4,2];Q.prototype.c=function(){Q.m.c.call(this);var a=this.b;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,ta)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var va="closure_listenable_"+(1E6*Math.random()|0),wa=0;function xa(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.j=!!d;this.b=e;this.o=++wa;this.h=this.i=!1}function ya(a){a.h=!0;a.listener=null;a.a=null;a.src=null;a.b=null};function za(a){this.src=a;this.a={};this.b=0};var R="closure_lm_"+(1E6*Math.random()|0),S={},Aa=0;
function Ba(a,b,c,d,e){if("array"==l(b)){for(var f=0;f<b.length;f++)Ba(a,b[f],c,d,e);return null}c=Ca(c);if(a&&a[va])a=Da(a,b,c,d,e);else{f=c;if(!b)throw Error("Invalid event type");c=!!d;var g=T(a);g||(a[R]=g=new za(a));var k=g,w=b.toString(),g=k.a[w];g||(g=k.a[w]=[],k.b++);var p;b:{for(p=0;p<g.length;++p){var n=g[p];if(!n.h&&n.listener==f&&n.j==!!d&&n.b==e)break b}p=-1}-1<p?(d=g[p],d.i=!1):(d=new xa(f,k.src,w,!!d,e),d.i=!1,g.push(d));if(!d.a){e=Ea();d.a=e;e.src=a;e.listener=d;if(a.addEventListener)a.addEventListener(b.toString(),
e,c);else if(a.attachEvent)a.attachEvent(Fa(b.toString()),e);else throw Error("addEventListener and attachEvent are unavailable.");Aa++}a=d}return a}function Ea(){var a=Ga,b=sa?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}
function Ha(a){if("number"!=typeof a&&a&&!a.h){var b=a.src;if(b&&b[va])b.v(a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.j):b.detachEvent&&b.detachEvent(Fa(c),d);Aa--;if(c=T(b)){var d=a.type,e;if(e=d in c.a){e=c.a[d];var f=ja(e,a),g;(g=0<=f)&&u.splice.call(e,f,1);e=g}e&&(ya(a),0==c.a[d].length&&(delete c.a[d],c.b--));0==c.b&&(c.src=null,b[R]=null)}else ya(a)}}}function Fa(a){return a in S?S[a]:S[a]="on"+a}
function Ia(a,b,c,d){var e=!0;if(a=T(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.j==c&&!f.h&&(f=Ja(f,d),e=e&&!1!==f)}return e}function Ja(a,b){var c=a.listener,d=a.b||a.src;a.i&&Ha(a);return c.call(d,b)}
function Ga(a,b){if(a.h)return!0;if(!sa){var c;if(!(c=b))a:{c=["window","event"];for(var d=h,e;e=c.shift();)if(null!=d[e])d=d[e];else{c=null;break a}c=d}e=c;c=new Q(e,this);d=!0;if(!(0>e.keyCode||void 0!=e.returnValue)){a:{var f=!1;if(0==e.keyCode)try{e.keyCode=-1;break a}catch(w){f=!0}if(f||void 0==e.returnValue)e.returnValue=!0}e=[];for(f=c.a;f;f=f.parentNode)e.push(f);for(var f=a.type,g=e.length-1;0<=g;g--){c.a=e[g];var k=Ia(e[g],f,!0,c),d=d&&k}for(g=0;g<e.length;g++)c.a=e[g],k=Ia(e[g],f,!1,c),
d=d&&k}return d}return Ja(a,new Q(b,this))}function T(a){a=a[R];return a instanceof za?a:null}var U="__closure_events_fn_"+(1E9*Math.random()>>>0);function Ca(a){if("function"==l(a))return a;a[U]||(a[U]=function(b){return a.handleEvent(b)});return a[U]};function V(a){q.call(this);this.f=a;this.c={}}m(V,q);var Ka=[];function Da(a,b,c,d,e){"array"!=l(c)&&(c&&(Ka[0]=c.toString()),c=Ka);for(var f=0;f<c.length;f++){var g=Ba(b,c[f],d||a.handleEvent,e||!1,a.f||a);if(!g)break;a.c[g.o]=g}return a}function La(a){ka(a.c,function(a,c){this.c.hasOwnProperty(c)&&Ha(a)},a);a.c={}}V.prototype.g=function(){V.m.g.call(this);La(this)};V.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented");};var Ma=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;function Na(a){return a?decodeURI(a):a}var Oa=/#|$/;
function Pa(a,b){var c=a.search(Oa),d;a:{d=0;for(var e=b.length;0<=(d=a.indexOf(b,d))&&d<c;){var f=a.charCodeAt(d-1);if(38==f||63==f)if(f=a.charCodeAt(d+e),!f||61==f||38==f||35==f)break a;d+=e+1}d=-1}if(0>d)return null;e=a.indexOf("&",d);if(0>e||e>c)e=c;d+=b.length+1;return decodeURIComponent(a.substr(d,e-d).replace(/\+/g," "))};function W(a){q.call(this);this.c=a||document.body;this.f=new V(this);a=aa(ba,this.f);this.b?a.call(void 0):(this.a||(this.a=[]),this.a.push(a));Da(this.f,this.c,"click",this.s,void 0)}m(W,q);
W.prototype.s=function(a){if((ra?0==a.b.button:"click"==a.type||a.b.button&ua[0])&&!(K&&ma&&a.g)&&!a.f)for(var b=a.target;b&&b!=this.c;){if(b.tagName&&"a"==b.tagName.toLowerCase()){var c=b.getAttribute("href")||b.getAttributeNS("http://www.w3.org/1999/xlink","href"),d,e=d=c;try{"www.google.com"==Na(d.match(Ma)[3]||null)&&"/url"==Na(d.match(Ma)[5]||null)&&(e=Pa(d,"q")||Pa(d,"url"))}catch(k){}d=e?e:"";if(c!=d){e=d;c={target:"_blank",noreferrer:!0};b=window;d=void 0;e instanceof v?d=e instanceof v&&
e.constructor===v&&e.a===y?"":"type_error:SafeUrl":d="undefined"!=typeof e.href?e.href:String(e);var e=c.target||e.target,f=[],g=void 0;for(g in c)switch(g){case "width":case "height":case "top":case "left":f.push(g+"="+c[g]);break;case "target":case "noreferrer":break;default:f.push(g+"="+(c[g]?1:0))}g=f.join(",");f=void 0;if((F("iPhone")&&!F("iPod")&&!F("iPad")||F("iPad")||F("iPod"))&&b.navigator&&b.navigator.standalone&&e&&"_self"!=e)f=b.document.createElement("A"),f.setAttribute("href",d),f.setAttribute("target",
e),c.noreferrer&&f.setAttribute("rel","noreferrer"),c=document.createEvent("MouseEvent"),c.initMouseEvent("click",!0,!0,b,1),f.dispatchEvent(c);else if(c.noreferrer){if(f=b.open("",e,g))la&&-1!=d.indexOf(";")&&(d="'"+d.replace(/'/g,"%27")+"'"),f.opener=null,b=d,ia.test(b)&&(-1!=b.indexOf("&")&&(b=b.replace(ca,"&amp;")),-1!=b.indexOf("<")&&(b=b.replace(da,"&lt;")),-1!=b.indexOf(">")&&(b=b.replace(ea,"&gt;")),-1!=b.indexOf('"')&&(b=b.replace(fa,"&quot;")),-1!=b.indexOf("'")&&(b=b.replace(ga,"&#39;")),
-1!=b.indexOf("\x00")&&(b=b.replace(ha,"&#0;"))),b=B('<META HTTP-EQUIV="refresh" content="0; url='+b+'">'),f.document.write(b instanceof z&&b.constructor===z&&b.b===A?b.a:"type_error:SafeHtml"),f.document.close()}else b.open(d,e,g);a.c();break}}b=b.parentNode}};function Qa(a){new W(a)}var X=["DOCS_installLinkReferrerSanitizer"],Y=h;X[0]in Y||!Y.execScript||Y.execScript("var "+X[0]);for(var Z;X.length&&(Z=X.shift());)X.length||void 0===Qa?Y[Z]?Y=Y[Z]:Y=Y[Z]={}:Y[Z]=Qa; })()
</SCRIPT>

<SCRIPT type=text/javascript>DOCS_installLinkReferrerSanitizer();</SCRIPT>
</BODY>